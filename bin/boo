#!/usr/bin/env bash
set -euo pipefail

MODE_FILE="${HOME}/.config/boo/mode.zsh"
THEME_FILE="${HOME}/.config/boo/theme"
THEME_ENV_FILE="${HOME}/.config/boo/theme.zsh"
PROMPT_FILE="${HOME}/.config/boo/prompt"
SPLASH_FILE="${HOME}/.config/boo/splash.zsh"
CUSTOM_SPLASH_FILE="${HOME}/.config/boo/custom-splash.txt"
BUILTIN_ART_DIR="${HOME}/.config/boo/art"
THEMES_DIR="${HOME}/.config/boo/themes"
DEFAULT_SPLASH="apple"
CONFIG_DIR="${HOME}/.config/boo"
SHELL_SNIPPET_FILE="${HOME}/.config/boo/boo.zsh"
ZSHRC_FILE="${HOME}/.zshrc"
LOCAL_BIN_DIR="${HOME}/.local/bin"
LOCAL_BIN_FILE="${HOME}/.local/bin/boo"
BOO_BLOCK_START="# >>> Boo >>>"
BOO_BLOCK_END="# <<< Boo <<<"
LEGACY_BLOCK_START="# >>> ObsiGhost >>>"
LEGACY_BLOCK_END="# <<< ObsiGhost <<<"
GHOSTTY_CONFIG_PRIMARY="${HOME}/.config/ghostty/config"
GHOSTTY_CONFIG_MAC="${HOME}/Library/Application Support/com.mitchellh.ghostty/config"
GHOSTTY_ORIGINAL_BACKUP_PRIMARY="${HOME}/.config/boo/backups/ghostty-config-primary.original"
GHOSTTY_ORIGINAL_BACKUP_MAC="${HOME}/.config/boo/backups/ghostty-config-mac.original"
BOO_GHOSTTY_MARKER="# Boo managed Ghostty config"
OMP_LEGACY_CONFIG="${HOME}/.config/ohmyposh/boo.omp.json"
OMP_CONFIG_DIR="${HOME}/.config/ohmyposh"
OMP_PRESET_DIR="${HOME}/.config/boo/ohmyposh"
DEFAULT_OPACITY="0.92"
DEFAULT_THEME="abyss"
DEFAULT_PROMPT_BACKEND="native"
DEFAULT_UPGRADE_URL="https://boo.ansub.co/install.sh"
UNAME_S="$(uname -s)"
UNSAFE_RELOAD_REASON=""
BOO_BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FALLBACK_THEMES_DIR="$(cd "${BOO_BIN_DIR}/.." >/dev/null 2>&1 && pwd)/themes"

ghostty_targets=()
_LOADED_THEME=""
_THEME_LOAD_ERROR=""

print_help() {
  local theme
  theme="$(read_theme_file)"
  _init_ui "$theme"

  local ca="$_ca" cb="$_cb" cd="$_cd" cl="$_cl" cv="$_cv" cr="$_cr"

  # cmd(9) · args(18) · desc
  _hcmd() {
    local cmd="$1" args="$2" desc="$3"
    local cp=$(( 9  - ${#cmd}  )); (( cp < 0 )) && cp=0
    local ap=$(( 18 - ${#args} )); (( ap < 0 )) && ap=0
    printf "  ${cb}${ca}${cmd}${cr}$(printf '%*s' $cp '')  ${cd}${args}${cr}$(printf '%*s' $ap '')  ${cv}${desc}${cr}\n"
  }

  printf "\n"
  if [[ -f "${BUILTIN_ART_DIR}/boo.txt" ]]; then
    while IFS= read -r line; do
      printf "  ${ca}%s${cr}\n" "$line"
    done < "${BUILTIN_ART_DIR}/boo.txt"
  fi
  printf "\n"
  printf "  ${cl}CONFIGURE${cr}\n"
  printf "\n"
  _hcmd "theme"     "[<name> · list · select · create · delete]"  "apply themes & ANSI palette"
  _hcmd "font"      "[<preset> · size]"  "font family & size"
  _hcmd "opacity"   "[glass · solid]"    "background opacity"
  _hcmd "splash"    "[<name> · none]"    "startup splash art"
  _hcmd "prompt"    "[native · omp]"     "shell prompt backend"
  _hcmd "mode"      "[full · public]"    "startup panel mode"
  printf "\n"
  printf "  ${cl}TOOLS${cr}\n"
  printf "\n"
  _hcmd "status"    ""                   "current config at a glance"
  _hcmd "reload"    "[--unsafe]"         "reload Ghostty config"
  _hcmd "upgrade"   ""                   "update boo to latest release"
  _hcmd "doctor"    "[fix]"              "diagnose & fix issues"
  _hcmd "uninstall" ""                   "remove boo completely"
  printf "\n"
  printf "  ${cd}boo theme list  ·  boo status  ·  boo doctor${cr}\n"
  printf "\n"
}

read_mode() {
  if [[ -f "$MODE_FILE" ]]; then
    if grep -q 'BOO_SHOW_PRIVATE=0' "$MODE_FILE"; then
      printf 'public\n'
      return
    fi
    if grep -q 'BOO_SHOW_PRIVATE=1' "$MODE_FILE"; then
      printf 'full\n'
      return
    fi
  fi
  if [[ "${BOO_SHOW_PRIVATE:-}" == "0" ]]; then
    printf 'public\n'
  else
    printf 'full\n'
  fi
}

write_mode_file() {
  local value="$1"
  mkdir -p "$(dirname "$MODE_FILE")"
  printf 'export BOO_SHOW_PRIVATE=%s\n' "$value" > "$MODE_FILE"
}

theme_name_is_safe() {
  local theme="$1"
  [[ "$theme" =~ ^[a-z0-9][a-z0-9_-]*$ ]]
}

theme_key_allowed() {
  local key="$1"
  case "$key" in
    description|accent|bg|fg|cursor|cursor_text|selection_bg|selection_fg|ui_dim|ui_label|ui_value|omp_chip_cloud_bg|omp_go_fg|omp_az_fg|omp_gcp_fg|omp_tf_fg|omp_sysinfo_fg|omp_git_bg|pal_[0-9]|pal_1[0-5])
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

theme_file_for_name() {
  local theme="$1"
  local file

  theme_name_is_safe "$theme" || return 1

  file="${THEMES_DIR}/${theme}.theme"
  if [[ -f "$file" ]]; then
    printf '%s\n' "$file"
    return 0
  fi

  file="${FALLBACK_THEMES_DIR}/${theme}.theme"
  if [[ -f "$file" ]]; then
    printf '%s\n' "$file"
    return 0
  fi

  return 1
}

list_theme_names() {
  local dir file name

  {
    for dir in "$THEMES_DIR" "$FALLBACK_THEMES_DIR"; do
      [[ -d "$dir" ]] || continue
      for file in "$dir"/*.theme; do
        [[ -e "$file" ]] || continue
        name="${file##*/}"
        name="${name%.theme}"
        if theme_name_is_safe "$name"; then
          printf '%s\n' "$name"
        fi
      done
    done
  } | awk '!seen[$0]++' | sort
}

list_valid_theme_names() {
  local name
  while IFS= read -r name; do
    [[ -n "$name" ]] || continue
    if load_theme "$name" >/dev/null 2>&1; then
      printf '%s\n' "$name"
    fi
  done < <(list_theme_names)
}

theme_names_pipe_separated() {
  local out
  out="$(list_valid_theme_names | paste -sd'|' -)"
  if [[ -n "$out" ]]; then
    printf '%s\n' "$out"
    return
  fi
  printf '%s\n' "$DEFAULT_THEME"
}

is_valid_theme() {
  local theme="$1"
  if ! theme_file_for_name "$theme" >/dev/null 2>&1; then
    return 1
  fi
  load_theme "$theme" >/dev/null 2>&1
}

reset_loaded_theme_vars() {
  local i
  unset _T_description _T_accent _T_bg _T_fg _T_cursor _T_cursor_text _T_selection_bg _T_selection_fg
  unset _T_ui_dim _T_ui_label _T_ui_value
  unset _T_omp_chip_cloud_bg _T_omp_go_fg _T_omp_az_fg _T_omp_gcp_fg _T_omp_tf_fg _T_omp_sysinfo_fg _T_omp_git_bg
  unset _T_panel_rgb
  for i in {0..15}; do
    unset "_T_pal_${i}"
  done
}

trim_ws() {
  local input="$1"
  input="${input#"${input%%[![:space:]]*}"}"
  input="${input%"${input##*[![:space:]]}"}"
  printf '%s' "$input"
}

load_theme() {
  local theme="$1"
  local file line raw_key raw_value key value var_name rgb
  local i
  local missing_keys=()

  if [[ "${_LOADED_THEME:-}" == "$theme" ]]; then
    return 0
  fi

  if ! file="$(theme_file_for_name "$theme")"; then
    _THEME_LOAD_ERROR="Theme not found: ${theme}"
    return 1
  fi

  reset_loaded_theme_vars

  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%$'\r'}"
    line="$(trim_ws "$line")"
    [[ -z "$line" ]] && continue
    [[ "${line:0:1}" == "#" ]] && continue

    if [[ "$line" != *=* ]]; then
      _THEME_LOAD_ERROR="Theme ${theme} has malformed line: ${line}"
      return 1
    fi

    raw_key="${line%%=*}"
    raw_value="${line#*=}"
    key="$(trim_ws "$raw_key")"
    value="$(trim_ws "$raw_value")"

    if ! theme_key_allowed "$key"; then
      _THEME_LOAD_ERROR="Theme ${theme} has unknown key: ${key}"
      return 1
    fi

    if [[ "$key" != "description" ]] && [[ ! "$value" =~ ^#[0-9A-Fa-f]{6}$ ]]; then
      _THEME_LOAD_ERROR="Theme ${theme} key ${key} must be #RRGGBB"
      return 1
    fi

    var_name="_T_${key}"
    if [[ "${!var_name+x}" == "x" ]]; then
      _THEME_LOAD_ERROR="Theme ${theme} has duplicate key: ${key}"
      return 1
    fi
    printf -v "$var_name" '%s' "$value"
  done < "$file"

  for key in description accent bg fg cursor cursor_text selection_bg selection_fg; do
    var_name="_T_${key}"
    if [[ -z "${!var_name:-}" ]]; then
      missing_keys+=("$key")
    fi
  done
  for i in {0..15}; do
    var_name="_T_pal_${i}"
    if [[ -z "${!var_name:-}" ]]; then
      missing_keys+=("pal_${i}")
    fi
  done
  if (( ${#missing_keys[@]} > 0 )); then
    _THEME_LOAD_ERROR="Theme ${theme} missing required keys: ${missing_keys[*]}"
    return 1
  fi

  [[ -n "${_T_omp_chip_cloud_bg:-}" ]] || _T_omp_chip_cloud_bg="$_T_selection_bg"
  [[ -n "${_T_omp_go_fg:-}" ]] || _T_omp_go_fg="$_T_fg"
  [[ -n "${_T_omp_az_fg:-}" ]] || _T_omp_az_fg="$_T_accent"
  [[ -n "${_T_omp_gcp_fg:-}" ]] || _T_omp_gcp_fg="$_T_accent"
  [[ -n "${_T_omp_tf_fg:-}" ]] || _T_omp_tf_fg="$_T_fg"
  [[ -n "${_T_omp_sysinfo_fg:-}" ]] || _T_omp_sysinfo_fg="$_T_fg"
  [[ -n "${_T_omp_git_bg:-}" ]] || _T_omp_git_bg="$_T_selection_bg"

  if ! rgb="$(hex_to_rgb "$_T_accent")"; then
    _THEME_LOAD_ERROR="Theme ${theme} has invalid accent color: $_T_accent"
    return 1
  fi
  _T_panel_rgb="$rgb"

  _THEME_LOAD_ERROR=""
  _LOADED_THEME="$theme"
  return 0
}

read_theme_file() {
  local theme first
  if [[ -f "$THEME_FILE" ]]; then
    theme="$(tr -d '[:space:]' < "$THEME_FILE")"
    if [[ -n "$theme" ]] && is_valid_theme "$theme"; then
      printf '%s\n' "$theme"
      return
    fi
  fi
  if is_valid_theme "$DEFAULT_THEME"; then
    printf '%s\n' "$DEFAULT_THEME"
    return
  fi
  first="$(list_theme_names | head -n1)"
  if [[ -n "$first" ]]; then
    printf '%s\n' "$first"
    return
  fi
  printf '%s\n' "$DEFAULT_THEME"
}

write_theme_file() {
  local theme="$1"
  mkdir -p "$(dirname "$THEME_FILE")"
  printf '%s\n' "$theme" > "$THEME_FILE"
}

omp_config_for_theme() {
  local theme="$1"
  theme_name_is_safe "$theme" || return 1
  printf '%s\n' "${OMP_CONFIG_DIR}/boo.${theme}.omp.json"
}

read_prompt_backend() {
  local backend
  if [[ -f "$PROMPT_FILE" ]]; then
    backend="$(tr -d '[:space:]' < "$PROMPT_FILE" | tr '[:upper:]' '[:lower:]')"
    case "$backend" in
      native|omp)
        printf '%s\n' "$backend"
        return
        ;;
      *)
        ;;
    esac
  fi
  printf '%s\n' "$DEFAULT_PROMPT_BACKEND"
}

write_prompt_backend() {
  local backend="$1"
  mkdir -p "$(dirname "$PROMPT_FILE")"
  printf '%s\n' "$backend" > "$PROMPT_FILE"
}

read_splash_name() {
  local splash
  if [[ -f "$SPLASH_FILE" ]]; then
    splash="$(grep -E '^export BOO_SPLASH=' "$SPLASH_FILE" | head -n1 | cut -d'=' -f2- | tr -d '"' | tr -d "'" | tr -d '[:space:]')"
    if [[ -n "$splash" ]]; then
      printf '%s\n' "$splash"
      return
    fi
  fi
  printf '%s\n' "$DEFAULT_SPLASH"
}

write_splash_name() {
  local splash="$1"
  mkdir -p "$(dirname "$SPLASH_FILE")"
  printf 'export BOO_SPLASH="%s"\n' "$splash" > "$SPLASH_FILE"
}

list_splash_names() {
  printf '%s\n' apple boo saturn eclipse halo monolith minimal
}

print_splash_preview() {
  local splash="$1"
  local source_file="${BUILTIN_ART_DIR}/${splash}.txt"

  if [[ "$splash" == "minimal" ]]; then
    printf '  (no ASCII art, info panel only)\n'
    return
  fi

  if [[ -f "$source_file" ]]; then
    head -n 3 "$source_file" | sed 's/^/  /'
    return
  fi

  printf '  (preview unavailable: %s)\n' "$source_file"
}

effective_prompt_backend() {
  local configured
  configured="$(read_prompt_backend)"
  if [[ "$configured" == "omp" ]] && ! command -v oh-my-posh >/dev/null 2>&1; then
    printf 'native\n'
    return
  fi
  printf '%s\n' "$configured"
}

print_command_box() {
  local cmd="$1"
  local pad=1
  local width=$(( ${#cmd} + (pad * 2) ))
  local border
  border="$(printf '%*s' "$width" '' | tr ' ' '─')"
  printf '┌%s┐\n' "$border"
  printf '│%*s%s%*s│\n' "$pad" '' "$cmd" "$pad" ''
  printf '└%s┘\n' "$border"
}

print_shell_apply_hint() {
  local _t
  _t="$(read_theme_file)"
  _init_ui "$_t"
  if [[ "${BOO_SHELL_WRAPPER:-0}" == "1" ]]; then
    printf "  \033[38;5;82m✓\033[0m  ${_cv}applied in this shell${_cr}\n\n"
    return
  fi
  printf "  ${_cd}run${_cr}  ${_cb}${_cv}exec zsh${_cr}  ${_cd}to apply in this shell${_cr}\n\n"
}

print_theme_applied_card() {
  local theme="$1"
  _init_ui "$theme"
  local accent="$_a" rgb="$_rgb"
  IFS=';' read -r r2 g2 b2 <<< "$rgb"
  local r1=$(( r2 / 8 )) g1=$(( g2 / 8 )) b1=$(( b2 / 8 ))

  local ca="$_ca" cb="$_cb" cd="$_cd" cl="$_cl" cv="$_cv" cr="$_cr"

  local inner=46
  local bar; bar="$(printf '%*s' "$inner" '' | tr ' ' '─')"

  _brow() {
    local vis="$1" content="$2"
    local pad=$(( inner - vis )); (( pad < 0 )) && pad=0
    printf "  ${ca}│${cr}%b%${pad}s${ca}│${cr}\n" "$content" ""
  }
  _bempty() { printf "  ${ca}│${cr}%${inner}s${ca}│${cr}\n" ""; }
  _bdiv()   { printf "  ${ca}├${bar}┤${cr}\n"; }

  # Gradient bar
  local grad="" i gr gg gb
  for (( i = 0; i < inner; i++ )); do
    gr=$(( r1 + (r2 - r1) * i / (inner - 1) ))
    gg=$(( g1 + (g2 - g1) * i / (inner - 1) ))
    gb=$(( b1 + (b2 - b1) * i / (inner - 1) ))
    grad+="\033[48;2;${gr};${gg};${gb}m \033[0m"
  done

  # Title: "boo" left + theme right
  local t_mid=$(( inner - 5 - ${#theme} - 2 ))
  (( t_mid < 0 )) && t_mid=0
  local title_row
  title_row="$(printf "  ${cb}${ca}boo${cr}%${t_mid}s${cd}${theme}${cr}  " "")"

  # Swatch row
  local sw_row="  \033[38;2;${rgb}m\033[48;2;${rgb}m████████${cr}  ${cb}${ca}${theme}${cr}  ${cd}${accent}${cr}"
  local sw_vis=$(( 2 + 8 + 2 + ${#theme} + 2 + ${#accent} ))

  # Shell hint row
  local shell_row shell_vis
  if [[ "${BOO_SHELL_WRAPPER:-0}" == "1" ]]; then
    shell_row="  ${ca}✓${cr}  ${cv}applied in this shell${cr}"
    shell_vis=$(( 2 + 1 + 2 + 22 ))
  else
    shell_row="  ${cd}run${cr}  ${cb}${ca}exec zsh${cr}  ${cd}to apply in this shell${cr}"
    shell_vis=$(( 2 + 3 + 2 + 8 + 2 + 22 ))
  fi

  printf "\n"
  printf "  ${ca}╭${bar}╮${cr}\n"
  _brow $inner "$grad"
  _brow $inner "$title_row"
  _bdiv
  _bempty
  _brow $sw_vis "$sw_row"
  _bempty
  _brow $(( 2 + 1 + 2 + 13 )) "  ${ca}✓${cr}  ${cv}theme applied${cr}"
  _brow $(( 2 + 1 + 2 + 22 )) "  ${ca}✓${cr}  ${cv}prompt accents updated${cr}"
  _brow $shell_vis "$shell_row"
  _brow $(( 2 + 1 + 2 + 19 + 2 + 1 + 2 + 11 )) "  ${cd}↺${cr}  ${cb}${ca}boo reload --unsafe${cr}  ${cd}·  Cmd+Shift+,${cr}"
  _bempty
  printf "  ${ca}╰${bar}╯${cr}\n"
  printf "\n"
}

doctor_ok_count=0
doctor_warn_count=0
doctor_fail_count=0

doctor_reset_counts() {
  doctor_ok_count=0
  doctor_warn_count=0
  doctor_fail_count=0
}

doctor_line() {
  local level="$1"
  local title="$2"
  local detail="${3:-}"
  local icon esc

  case "$level" in
    ok)
      icon="✓"; esc="\033[38;5;82m"
      doctor_ok_count=$((doctor_ok_count + 1))
      ;;
    warn)
      icon="!"; esc="\033[38;5;214m"
      doctor_warn_count=$((doctor_warn_count + 1))
      ;;
    fail)
      icon="✗"; esc="\033[38;5;196m"
      doctor_fail_count=$((doctor_fail_count + 1))
      ;;
    *)
      icon="·"; esc="\033[38;5;244m"
      ;;
  esac

  printf "  ${esc}${icon}\033[0m  ${_cv}%s${_cr}\n" "$title"
  if [[ -n "$detail" ]]; then
    printf "       ${_cd}%s${_cr}\n" "$detail"
  fi
}

doctor_has_zshrc_boo_block() {
  if [[ ! -f "$ZSHRC_FILE" ]]; then
    return 1
  fi
  grep -qF "$BOO_BLOCK_START" "$ZSHRC_FILE" && grep -qF "$BOO_BLOCK_END" "$ZSHRC_FILE"
}

doctor_path_has_local_bin() {
  case ":${PATH}:" in
    *":${LOCAL_BIN_DIR}:"*) return 0 ;;
    *) return 1 ;;
  esac
}

doctor_file_hash() {
  local file="$1"
  if command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$file" | awk '{print $1}'
    return
  fi
  cksum "$file" | awk '{print $1 "-" $2}'
}

remove_marked_block() {
  local file="$1"
  local start="$2"
  local end="$3"
  local tmp
  tmp="$(mktemp)"
  awk -v start="$start" -v end="$end" '
    $0 ~ start { skip = 1; next }
    $0 ~ end { skip = 0; next }
    skip != 1 { print }
  ' "$file" > "$tmp"
  mv "$tmp" "$file"
}

doctor_clean_legacy_marked_block() {
  local file="$1"
  remove_marked_block "$file" "$LEGACY_BLOCK_START" "$LEGACY_BLOCK_END"
}

doctor_remove_obsighost_lines() {
  local file="$1"
  local tmp
  tmp="$(mktemp)"
  awk '
    /obsighost\.omp\.json/ { next }
    /source .*\.config\/obsighost\/obsighost\.zsh/ { next }
    /^obsighost_apply_highlight_colors$/ { next }
    { print }
  ' "$file" > "$tmp"
  mv "$tmp" "$file"
}

doctor_ensure_zshrc_path_and_block() {
  if [[ ! -f "$ZSHRC_FILE" ]]; then
    touch "$ZSHRC_FILE"
  fi

  if ! grep -q 'PATH=.*\.local/bin' "$ZSHRC_FILE"; then
    cat >> "$ZSHRC_FILE" <<'EOF'

export PATH="$HOME/.local/bin:$PATH"
EOF
  fi

  if ! doctor_has_zshrc_boo_block; then
    cat >> "$ZSHRC_FILE" <<'EOF'

# >>> Boo >>>
if [[ -f "$HOME/.config/boo/boo.zsh" ]]; then
  source "$HOME/.config/boo/boo.zsh"
fi
# <<< Boo <<<
EOF
  fi
}

doctor_apply_fixes() {
  local self_bin
  local script_dir script_root snippet_source
  local old_backend

  printf "\n  ${_cl}APPLYING FIXES${_cr}\n\n"
  mkdir -p "$CONFIG_DIR" "$LOCAL_BIN_DIR"

  doctor_ensure_zshrc_path_and_block

  if [[ -f "$ZSHRC_FILE" ]]; then
    doctor_clean_legacy_marked_block "$ZSHRC_FILE"
    doctor_remove_obsighost_lines "$ZSHRC_FILE"
  fi

  if [[ ! -f "$PROMPT_FILE" ]]; then
    printf '%s\n' "$DEFAULT_PROMPT_BACKEND" > "$PROMPT_FILE"
  fi

  if [[ ! -f "$THEME_FILE" ]]; then
    printf '%s\n' "$DEFAULT_THEME" > "$THEME_FILE"
  fi

  mkdir -p "$THEMES_DIR"
  if [[ -d "$FALLBACK_THEMES_DIR" ]] && ! compgen -G "${THEMES_DIR}/*.theme" > /dev/null; then
    cp "$FALLBACK_THEMES_DIR"/*.theme "$THEMES_DIR/" 2>/dev/null || true
  fi

  if [[ ! -f "$THEME_ENV_FILE" ]]; then
    cat > "$THEME_ENV_FILE" <<'EOF'
export BOO_THEME="abyss"
export BOO_ACCENT_COLOR="#cc44ff"
export BOO_PANEL_COLOR_RGB="204;68;255"
EOF
  fi

  old_backend="$(read_prompt_backend)"
  if [[ "$old_backend" == "omp" ]] && ! command -v oh-my-posh >/dev/null 2>&1; then
    write_prompt_backend "native"
  fi

  script_dir="$(cd "$(dirname "$0")" && pwd)"
  script_root="$(cd "$script_dir/.." && pwd)"
  snippet_source="${script_root}/shell/boo.zsh"
  if [[ ! -f "$SHELL_SNIPPET_FILE" && -f "$snippet_source" ]]; then
    cp "$snippet_source" "$SHELL_SNIPPET_FILE"
  fi

  self_bin="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
  if [[ -f "$self_bin" ]]; then
    if [[ "$self_bin" != "$LOCAL_BIN_FILE" ]]; then
      cp "$self_bin" "$LOCAL_BIN_FILE"
    fi
    chmod +x "$LOCAL_BIN_FILE"
  fi
}

doctor_run_checks() {
  local configured_backend effective_backend
  local command_path
  local local_hash mac_hash
  local refs active_theme

  doctor_reset_counts
  printf "\n  ${_cl}DOCTOR${_cr}\n\n"

  if [[ -x "$LOCAL_BIN_FILE" ]]; then
    doctor_line ok "CLI binary exists" "$LOCAL_BIN_FILE"
  else
    doctor_line fail "CLI binary missing/executable bit not set" "$LOCAL_BIN_FILE"
  fi

  command_path="$(command -v boo 2>/dev/null || true)"
  if [[ -n "$command_path" ]]; then
    doctor_line ok "boo resolves in PATH" "$command_path"
  else
    doctor_line warn "boo command not found in current PATH" "Run: exec zsh (or add $LOCAL_BIN_DIR to PATH)."
  fi

  if doctor_path_has_local_bin; then
    doctor_line ok "PATH contains ~/.local/bin"
  else
    doctor_line warn "PATH missing ~/.local/bin in current shell"
  fi

  if [[ -f "$SHELL_SNIPPET_FILE" ]]; then
    doctor_line ok "Shell snippet exists" "$SHELL_SNIPPET_FILE"
  else
    doctor_line warn "Shell snippet missing" "$SHELL_SNIPPET_FILE"
  fi

  if list_theme_names | grep -q .; then
    doctor_line ok "Theme files discovered" "$THEMES_DIR"
  else
    doctor_line fail "No theme files found" "Run installer or add files to $THEMES_DIR."
  fi

  active_theme="$(read_theme_file)"
  if is_valid_theme "$active_theme"; then
    doctor_line ok "Active theme file found" "$active_theme"
  else
    doctor_line warn "Active theme file missing" "$active_theme"
  fi

  if doctor_has_zshrc_boo_block; then
    doctor_line ok "Boo source block present in ~/.zshrc"
  else
    doctor_line warn "Boo source block missing in ~/.zshrc" "Run: boo doctor fix"
  fi

  refs="$(grep -nE 'obsighost|\.config/obsighost' "$ZSHRC_FILE" 2>/dev/null || true)"
  if [[ -n "$refs" ]]; then
    doctor_line warn "Legacy obsighost references found in ~/.zshrc" "Run: boo doctor fix"
  else
    doctor_line ok "No legacy obsighost references in ~/.zshrc"
  fi

  configured_backend="$(read_prompt_backend)"
  effective_backend="$(effective_prompt_backend)"
  doctor_line ok "Prompt backend" "configured=${configured_backend}, active=${effective_backend}"
  if [[ "$configured_backend" == "omp" && "$effective_backend" == "native" ]]; then
    doctor_line warn "oh-my-posh missing while prompt backend is omp" "Install oh-my-posh or run: boo prompt set native"
  fi

  if [[ -s "$GHOSTTY_CONFIG_PRIMARY" && -s "$GHOSTTY_CONFIG_MAC" ]]; then
    local_hash="$(doctor_file_hash "$GHOSTTY_CONFIG_PRIMARY")"
    mac_hash="$(doctor_file_hash "$GHOSTTY_CONFIG_MAC")"
    if [[ "$local_hash" != "$mac_hash" ]]; then
      doctor_line warn "Ghostty config mismatch across two locations" "$GHOSTTY_CONFIG_PRIMARY and $GHOSTTY_CONFIG_MAC differ."
    else
      doctor_line ok "Ghostty config mirrored in both locations"
    fi
  else
    doctor_line ok "Ghostty config path setup has no split conflict"
  fi

  local _ok_c="\033[38;5;82m" _warn_c="\033[38;5;214m" _fail_c="\033[38;5;244m"
  (( doctor_fail_count > 0 )) && _fail_c="\033[38;5;196m"
  (( doctor_warn_count > 0 )) && _warn_c="\033[38;5;214m"
  printf "\n  ${_cl}%b%d ok${_cl}  ·  %b%d warn${_cl}  ·  %b%d fail${_cr}\n\n" \
    "$_ok_c" "$doctor_ok_count" "$_warn_c" "$doctor_warn_count" "$_fail_c" "$doctor_fail_count"
  if (( doctor_fail_count > 0 )); then
    return 1
  fi
  return 0
}

theme_accent_color() {
  local theme="$1"
  if load_theme "$theme"; then
    printf '%s\n' "$_T_accent"
    return 0
  fi
  printf '#cc44ff\n'
  return 1
}

theme_panel_rgb() {
  local theme="$1"
  if load_theme "$theme"; then
    printf '%s\n' "$_T_panel_rgb"
    return 0
  fi
  printf '204;68;255\n'
  return 1
}

# Sets standard UI color escape vars for themed output.
# After calling: _ca=accent _cb=bold _cd=dim _cl=label _cv=value _cr=reset
_init_ui() {
  local theme="$1"
  local accent rgb dim_rgb label_rgb value_rgb

  if ! load_theme "$theme"; then
    if [[ "$theme" != "$DEFAULT_THEME" ]]; then
      load_theme "$DEFAULT_THEME" || true
    fi
  fi

  accent="${_T_accent:-#cc44ff}"
  rgb="$(hex_to_rgb "$accent" 2>/dev/null || printf '204;68;255')"
  _ca="\033[38;2;${rgb}m"
  _cb="\033[1m"
  _cr="\033[0m"
  _a="$accent"
  _rgb="$rgb"

  if [[ -n "${_T_ui_dim:-}" && -n "${_T_ui_label:-}" && -n "${_T_ui_value:-}" ]]; then
    dim_rgb="$(hex_to_rgb "$_T_ui_dim" 2>/dev/null || true)"
    label_rgb="$(hex_to_rgb "$_T_ui_label" 2>/dev/null || true)"
    value_rgb="$(hex_to_rgb "$_T_ui_value" 2>/dev/null || true)"
    if [[ -n "$dim_rgb" && -n "$label_rgb" && -n "$value_rgb" ]]; then
      _cd="\033[38;2;${dim_rgb}m"
      _cl="\033[38;2;${label_rgb}m"
      _cv="\033[38;2;${value_rgb}m"
      return
    fi
  fi

  _cd="\033[38;5;237m"
  _cl="\033[38;5;244m"
  _cv="\033[38;5;252m"
}

theme_core_colors() {
  local theme="$1"
  if ! load_theme "$theme"; then
    return 1
  fi
  cat <<EOF
bg=${_T_bg}
fg=${_T_fg}
accent=${_T_accent}
cursor=${_T_cursor}
selection=${_T_selection_bg}
EOF
}

hex_to_rgb() {
  local hex="${1#\#}"
  if [[ ! "$hex" =~ ^[0-9A-Fa-f]{6}$ ]]; then
    return 1
  fi
  printf '%d;%d;%d\n' "0x${hex:0:2}" "0x${hex:2:2}" "0x${hex:4:2}"
}

# ── color math (pure bash integer arithmetic) ───────────────────────

hex_to_r() { printf '%d' "0x${1:1:2}"; }
hex_to_g() { printf '%d' "0x${1:3:2}"; }
hex_to_b() { printf '%d' "0x${1:5:2}"; }

rgb_to_hex() {
  printf '#%02x%02x%02x' "$1" "$2" "$3"
}

# blend_color hex1 hex2 ratio  (ratio 0-1000: 0=hex1, 1000=hex2)
blend_color() {
  local r1 g1 b1 r2 g2 b2 t="$3"
  r1=$(hex_to_r "$1"); g1=$(hex_to_g "$1"); b1=$(hex_to_b "$1")
  r2=$(hex_to_r "$2"); g2=$(hex_to_g "$2"); b2=$(hex_to_b "$2")
  local r=$(( (r1 * (1000 - t) + r2 * t) / 1000 ))
  local g=$(( (g1 * (1000 - t) + g2 * t) / 1000 ))
  local b=$(( (b1 * (1000 - t) + b2 * t) / 1000 ))
  (( r > 255 )) && r=255; (( r < 0 )) && r=0
  (( g > 255 )) && g=255; (( g < 0 )) && g=0
  (( b > 255 )) && b=255; (( b < 0 )) && b=0
  rgb_to_hex "$r" "$g" "$b"
}

hex_luma() {
  local hex="$1"
  local r g b
  r=$(hex_to_r "$hex")
  g=$(hex_to_g "$hex")
  b=$(hex_to_b "$hex")
  printf '%d\n' $(( (r * 299 + g * 587 + b * 114) / 1000 ))
}

theme_mode_for_bg() {
  local bg="$1"
  local bg_l
  bg_l=$(hex_luma "$bg")
  if (( bg_l >= 150 )); then
    printf 'light\n'
  else
    printf 'dark\n'
  fi
}

theme_palette_strip_main() {
  local hex rgb
  local main_colors=(
    "$_T_bg"
    "$_T_fg"
    "$_T_accent"
    "$_T_cursor"
    "$_T_selection_bg"
  )

  for hex in "${main_colors[@]}"; do
    rgb="$(hex_to_rgb "$hex" 2>/dev/null || printf '128;128;128')"
    printf '\033[38;2;%s;48;2;%sm███\033[0m' "$rgb" "$rgb"
  done
}

theme_selector_rows() {
  local active_theme="${1:-}"
  local name accent_rgb mode marker colored_name description row
  local -a dark_rows=()
  local -a light_rows=()

  while IFS= read -r name; do
    [[ -n "$name" ]] || continue
    if ! load_theme "$name"; then
      continue
    fi

    accent_rgb="$(hex_to_rgb "$_T_accent" 2>/dev/null || printf '204;68;255')"
    mode="$(theme_mode_for_bg "$_T_bg")"
    marker=" "
    [[ "$name" == "$active_theme" ]] && marker="*"
    colored_name="$(printf '\033[38;2;%sm%s\033[0m' "$accent_rgb" "$name")"
    description="${_T_description:-no description}"
    description="${description//$'\t'/ }"

    row="$(printf '%s\t%s\t%s\t%s\t%s' "$name" "$marker" "$mode" "$colored_name" "$description")"
    if [[ "$mode" == "light" ]]; then
      light_rows+=("$row")
    else
      dark_rows+=("$row")
    fi
  done < <(list_theme_names)

  if (( ${#dark_rows[@]} > 0 )); then
    printf '__section__\t \t \t\033[1mDARK THEMES\033[0m\t\n'
    printf '%s\n' "${dark_rows[@]}"
  fi
  if (( ${#light_rows[@]} > 0 )); then
    if (( ${#dark_rows[@]} > 0 )); then
      printf '__section__\t \t \t\033[2m────────────────\033[0m\t\n'
    fi
    printf '__section__\t \t \t\033[1mLIGHT THEMES\033[0m\t\n'
    printf '%s\n' "${light_rows[@]}"
  fi
}

preview_fit_text() {
  local width="$1"
  local text="$2"

  (( width < 1 )) && return
  if (( ${#text} > width )); then
    if (( width > 3 )); then
      text="${text:0:$((width - 3))}..."
    else
      text="${text:0:$width}"
    fi
  fi
  printf '%-*s' "$width" "$text"
}

print_preview_terminal_row() {
  local inner="$1"
  local bg_rgb="$2"
  local fg_rgb="$3"
  local text="$4"
  local border_rgb="${5:-140;140;140}"
  local row

  row="$(preview_fit_text "$inner" "$text")"
  printf '  \033[38;2;%sm│\033[48;2;%sm\033[38;2;%sm%s\033[0m\033[38;2;%sm│\033[0m\n' \
    "$border_rgb" "$bg_rgb" "$fg_rgb" "$row" "$border_rgb"
}

print_theme_selector_preview() {
  local theme="${1:-}"
  local accent_rgb mode
  local bg_rgb fg_rgb cursor_rgb cursor_text_rgb sel_bg_rgb sel_fg_rgb
  local ok_rgb warn_rgb err_rgb info_rgb
  local border_rgb muted_rgb
  local preview_cols inner line border

  if [[ -z "$theme" ]]; then
    printf 'No theme selected.\n'
    return 1
  fi
  if [[ "$theme" == "__section__" ]]; then
    printf '\n  Select a theme row to preview it.\n\n'
    return 0
  fi

  if ! load_theme "$theme"; then
    printf 'Invalid theme: %s\n' "$theme"
    if [[ -n "${_THEME_LOAD_ERROR:-}" ]]; then
      printf '%s\n' "$_THEME_LOAD_ERROR"
    fi
    return 1
  fi

  accent_rgb="$(hex_to_rgb "$_T_accent" 2>/dev/null || printf '204;68;255')"
  bg_rgb="$(hex_to_rgb "$_T_bg" 2>/dev/null || printf '12;12;12')"
  fg_rgb="$(hex_to_rgb "$_T_fg" 2>/dev/null || printf '220;220;220')"
  cursor_rgb="$(hex_to_rgb "$_T_cursor" 2>/dev/null || printf '255;255;255')"
  cursor_text_rgb="$(hex_to_rgb "$_T_cursor_text" 2>/dev/null || printf '0;0;0')"
  sel_bg_rgb="$(hex_to_rgb "$_T_selection_bg" 2>/dev/null || printf '70;70;70')"
  sel_fg_rgb="$(hex_to_rgb "$_T_selection_fg" 2>/dev/null || printf '235;235;235')"
  ok_rgb="$(hex_to_rgb "$_T_pal_10" 2>/dev/null || printf '120;210;120')"
  warn_rgb="$(hex_to_rgb "$_T_pal_11" 2>/dev/null || printf '230;190;90')"
  err_rgb="$(hex_to_rgb "$_T_pal_1" 2>/dev/null || printf '230;95;95')"
  info_rgb="$(hex_to_rgb "$_T_pal_12" 2>/dev/null || printf '110;170;240')"
  border_rgb="$(hex_to_rgb "$_T_pal_8" 2>/dev/null || printf '120;120;120')"
  muted_rgb="$(hex_to_rgb "$_T_pal_7" 2>/dev/null || printf '170;170;170')"
  mode="$(theme_mode_for_bg "$_T_bg")"
  preview_cols="${FZF_PREVIEW_COLUMNS:-80}"
  (( preview_cols < 44 )) && preview_cols=44
  inner=$(( preview_cols - 4 ))
  border="$(printf '%*s' "$inner" '' | tr ' ' '─')"

  printf '\n'
  printf '  \033[1m\033[38;2;%sm%s\033[0m  (%s)\n' "$accent_rgb" "$theme" "$mode"
  printf '  \033[38;5;244m%s\033[0m\n\n' "${_T_description:-no description}"

  printf '  \033[38;2;%sm╭%s╮\033[0m\n' "$border_rgb" "$border"
  line="$(preview_fit_text "$inner" '  o  o  o    boo terminal')"
  printf '  \033[38;2;%sm│\033[48;2;%sm\033[38;2;%sm%s\033[0m\033[38;2;%sm│\033[0m\n' \
    "$border_rgb" "$sel_bg_rgb" "$sel_fg_rgb" "$line" "$border_rgb"
  print_preview_terminal_row "$inner" "$bg_rgb" "$fg_rgb" " > boo theme $theme" "$border_rgb"
  print_preview_terminal_row "$inner" "$bg_rgb" "$ok_rgb" "   [ok] theme applied" "$border_rgb"
  print_preview_terminal_row "$inner" "$bg_rgb" "$fg_rgb" " > boo doctor" "$border_rgb"
  print_preview_terminal_row "$inner" "$bg_rgb" "$warn_rgb" "   7 ok  -  1 warn  -  0 fail" "$border_rgb"
  print_preview_terminal_row "$inner" "$bg_rgb" "$fg_rgb" " > echo ready" "$border_rgb"
  print_preview_terminal_row "$inner" "$bg_rgb" "$info_rgb" "   ready" "$border_rgb"
  line="$(preview_fit_text "$inner" '   typing...')"
  printf '  \033[38;2;%sm│\033[48;2;%sm\033[38;2;%sm%s\033[48;2;%sm\033[38;2;%sm|\033[48;2;%sm\033[38;2;%sm\033[0m\033[38;2;%sm│\033[0m\n' \
    "$border_rgb" "$bg_rgb" "$fg_rgb" "${line:0:$((inner - 1))}" "$cursor_rgb" "$cursor_text_rgb" "$bg_rgb" "$fg_rgb" "$border_rgb"
  printf '  \033[38;2;%sm╰%s╯\033[0m\n' "$border_rgb" "$border"

  printf '\n  \033[38;2;%smmain colors\033[0m  %s\n\n' "$muted_rgb" "$(theme_palette_strip_main)"
}

cmd_theme_select() {
  local _t active chosen preview_cmd selected_line rows
  _t="$(read_theme_file)"
  _init_ui "$_t"

  if ! command -v fzf >/dev/null 2>&1; then
    printf "\n  ${_cv}fzf is required for interactive theme selection${_cr}\n"
    printf "  ${_cd}install fzf, then run:${_cr} ${_ca}boo theme select${_cr}\n"
    printf "  ${_cd}fallback:${_cr} ${_ca}boo theme list${_cr}\n\n"
    return 1
  fi

  active="$(read_theme_file)"
  rows="$(theme_selector_rows "$active")"
  if [[ -z "$rows" ]]; then
    printf "\n  ${_cd}No themes found in %s${_cr}\n\n" "$THEMES_DIR"
    return 1
  fi

  printf -v preview_cmd '%q __theme_selector_preview {1}' "${BOO_BIN_DIR}/boo"

  while true; do
    selected_line="$(
      printf '%s\n' "$rows" | \
        fzf --ansi \
          --delimiter=$'\t' \
          --with-nth=2,3,4,5 \
          --height=90% \
          --layout=reverse \
          --border \
          --prompt="theme > " \
          --header=$'Enter: apply theme - Esc: cancel' \
          --preview="$preview_cmd" \
          --preview-window="right:62%:nowrap"
    )" || return 0

    chosen="${selected_line%%$'\t'*}"
    [[ -n "$chosen" ]] || continue
    if [[ "$chosen" == "__section__" ]]; then
      continue
    fi
    break
  done

  if [[ "$chosen" == "$active" ]]; then
    printf "\n  ${_cd}%s is already active${_cr}\n\n" "$chosen"
    return 0
  fi

  apply_theme "$chosen"
  print_theme_applied_card "$chosen"
  cmd_reload > /dev/null 2>&1 || true
}

theme_text_color_for_bg() {
  local bg="$1"
  local bg_l dark_l light_l diff_dark diff_light
  bg_l=$(hex_luma "$bg")
  dark_l=$(hex_luma "$_T_pal_0")
  light_l=$(hex_luma "$_T_pal_15")

  diff_dark=$(( bg_l - dark_l ))
  (( diff_dark < 0 )) && diff_dark=$(( -diff_dark ))
  diff_light=$(( bg_l - light_l ))
  (( diff_light < 0 )) && diff_light=$(( -diff_light ))

  if (( diff_dark >= diff_light )); then
    printf '%s\n' "$_T_pal_0"
  else
    printf '%s\n' "$_T_pal_15"
  fi
}

readable_color_or_theme_text() {
  local bg="$1"
  local preferred="$2"
  local threshold="${3:-125}"
  local bg_l pref_l diff

  bg_l=$(hex_luma "$bg")
  pref_l=$(hex_luma "$preferred")
  diff=$(( bg_l - pref_l ))
  (( diff < 0 )) && diff=$(( -diff ))

  if (( diff >= threshold )); then
    printf '%s\n' "$preferred"
  else
    theme_text_color_for_bg "$bg"
  fi
}

# tint_white: near-white ceiling tinted toward the accent hue
tint_white() {
  local r g b max
  r=$(hex_to_r "$1"); g=$(hex_to_g "$1"); b=$(hex_to_b "$1")
  max=$r; (( g > max )) && max=$g; (( b > max )) && max=$b
  (( max == 0 )) && max=1
  # scale channels so max→255, then blend 80% toward pure white
  local sr=$(( r * 255 / max ))
  local sg=$(( g * 255 / max ))
  local sb=$(( b * 255 / max ))
  local wr=$(( (sr * 200 + 255 * 800) / 1000 ))
  local wg=$(( (sg * 200 + 255 * 800) / 1000 ))
  local wb=$(( (sb * 200 + 255 * 800) / 1000 ))
  (( wr > 255 )) && wr=255; (( wg > 255 )) && wg=255; (( wb > 255 )) && wb=255
  rgb_to_hex "$wr" "$wg" "$wb"
}

generate_theme() {
  local accent="$1" name="$2"
  local tw
  tw="$(tint_white "$accent")"

  local bg fg sel_bg sel_fg
  bg="$(blend_color "$accent" "#000000" 930)"
  fg="$(blend_color "$accent" "$tw" 450)"
  sel_bg="$(blend_color "$accent" "#000000" 820)"
  sel_fg="$(blend_color "$accent" "$tw" 750)"

  local p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15
  p0="$bg"
  p1="$(blend_color "#000000" "$accent" 200)"
  p2="$(blend_color "#000000" "$accent" 350)"
  p3="$(blend_color "#000000" "$accent" 500)"
  p4="$(blend_color "#000000" "$accent" 130)"
  p5="$accent"
  p6="$(blend_color "#000000" "$accent" 620)"
  p7="$(blend_color "$accent" "$tw" 400)"
  p8="$(blend_color "$accent" "#000000" 890)"
  p9="$(blend_color "#000000" "$accent" 450)"
  p10="$(blend_color "#000000" "$accent" 580)"
  p11="$(blend_color "#000000" "$accent" 750)"
  p12="$(blend_color "#000000" "$accent" 300)"
  p13="$(blend_color "$accent" "$tw" 300)"
  p14="$(blend_color "$accent" "$tw" 180)"
  p15="$(blend_color "$accent" "$tw" 750)"

  local omp_cloud omp_go omp_az omp_gcp omp_tf omp_sys omp_git
  omp_cloud="$(blend_color "$accent" "#000000" 800)"
  omp_go="$(blend_color "$accent" "$tw" 250)"
  omp_az="$accent"
  omp_gcp="$(blend_color "$accent" "$tw" 150)"
  omp_tf="$(blend_color "$accent" "$tw" 350)"
  omp_sys="$(blend_color "$accent" "$tw" 200)"
  omp_git="$(blend_color "$accent" "#000000" 750)"

  # auto-description from dominant channel
  local r g b desc_adj max min spread
  r=$(hex_to_r "$accent"); g=$(hex_to_g "$accent"); b=$(hex_to_b "$accent")
  max=$r; (( g > max )) && max=$g; (( b > max )) && max=$b
  min=$r; (( g < min )) && min=$g; (( b < min )) && min=$b
  spread=$(( max - min ))
  if (( spread < 30 )); then
    desc_adj="neutral"
  elif (( r >= g && r >= b )); then
    if (( g > b + 40 )); then desc_adj="warm amber"
    elif (( b > g + 40 )); then desc_adj="cool rose"
    else desc_adj="warm red"
    fi
  elif (( g >= r && g >= b )); then
    if (( r > b + 40 )); then desc_adj="earthy green"
    elif (( b > r + 40 )); then desc_adj="cool teal"
    else desc_adj="verdant green"
    fi
  else
    if (( r > g + 40 )); then desc_adj="vivid violet"
    elif (( g > r + 40 )); then desc_adj="cool indigo"
    else desc_adj="deep blue"
    fi
  fi

  printf 'description=%s %s - generated theme\n' "$desc_adj" "$name"
  printf 'accent=%s\n' "$accent"
  printf 'bg=%s\n' "$bg"
  printf 'fg=%s\n' "$fg"
  printf 'cursor=%s\n' "$accent"
  printf 'cursor_text=#000000\n'
  printf 'selection_bg=%s\n' "$sel_bg"
  printf 'selection_fg=%s\n' "$sel_fg"
  printf 'omp_chip_cloud_bg=%s\n' "$omp_cloud"
  printf 'omp_go_fg=%s\n' "$omp_go"
  printf 'omp_az_fg=%s\n' "$omp_az"
  printf 'omp_gcp_fg=%s\n' "$omp_gcp"
  printf 'omp_tf_fg=%s\n' "$omp_tf"
  printf 'omp_sysinfo_fg=%s\n' "$omp_sys"
  printf 'omp_git_bg=%s\n' "$omp_git"
  printf 'pal_0=%s\n' "$p0"
  printf 'pal_1=%s\n' "$p1"
  printf 'pal_2=%s\n' "$p2"
  printf 'pal_3=%s\n' "$p3"
  printf 'pal_4=%s\n' "$p4"
  printf 'pal_5=%s\n' "$p5"
  printf 'pal_6=%s\n' "$p6"
  printf 'pal_7=%s\n' "$p7"
  printf 'pal_8=%s\n' "$p8"
  printf 'pal_9=%s\n' "$p9"
  printf 'pal_10=%s\n' "$p10"
  printf 'pal_11=%s\n' "$p11"
  printf 'pal_12=%s\n' "$p12"
  printf 'pal_13=%s\n' "$p13"
  printf 'pal_14=%s\n' "$p14"
  printf 'pal_15=%s\n' "$p15"
}

# ── end color math ──────────────────────────────────────────────────

print_color_swatch_line() {
  local label="$1"
  local hex="$2"
  local rgb
  rgb="$(hex_to_rgb "$hex")" || return 1

  printf '  %-9s ' "$label"
  printf '\033[38;2;%s;48;2;%sm████\033[0m ' "$rgb" "$rgb"
  printf '\033[38;2;%sm%s\033[0m\n' "$rgb" "$hex"
}

print_color_plain_line() {
  local label="$1"
  local hex="$2"
  printf '  %-9s %s\n' "$label" "$hex"
}

print_theme_preview() {
  local theme="$1"
  local plain="${2:-0}"
  local line key value

  printf '%s\n' "$theme"
  while IFS= read -r line; do
    key="${line%%=*}"
    value="${line#*=}"
    if (( plain == 1 )); then
      print_color_plain_line "$key" "$value"
    else
      print_color_swatch_line "$key" "$value"
    fi
  done < <(theme_core_colors "$theme")
  printf '  Apply? boo theme %s\n' "$theme"
}

print_preview_all_row() {
  local theme="$1"
  local plain="${2:-0}"
  local line key value rgb
  local accent accent_rgb
  local values=()

  if (( plain == 1 )); then
    local bg="" fg="" accent_val="" cursor="" selection=""
    while IFS= read -r line; do
      key="${line%%=*}"
      value="${line#*=}"
      case "$key" in
        bg) bg="$value" ;;
        fg) fg="$value" ;;
        accent) accent_val="$value" ;;
        cursor) cursor="$value" ;;
        selection) selection="$value" ;;
      esac
    done < <(theme_core_colors "$theme")
    printf '%-10s bg=%s fg=%s accent=%s cursor=%s selection=%s boo theme %s\n' \
      "$theme" "$bg" "$fg" "$accent_val" "$cursor" "$selection" "$theme"
    return
  fi

  while IFS= read -r line; do
    values+=("${line#*=}")
  done < <(theme_core_colors "$theme")

  _init_ui "$theme"
  local ca="$_ca" cb="$_cb" cd="$_cd" cr="$_cr"

  # Line 1: theme name in its accent color + wide swatches + dim hint
  printf "  ${cb}${ca}%-12s${cr}" "$theme"
  for value in "${values[@]}"; do
    rgb="$(hex_to_rgb "$value")"
    printf " \033[38;2;%s;48;2;%sm███████\033[0m" "$rgb" "$rgb"
  done
  printf "  ${cd}boo theme %s${cr}\n" "$theme"

  # Line 2: dim hex values aligned under swatches
  printf "  %-12s" ""
  for value in "${values[@]}"; do
    printf " ${cd}%-7s${cr}" "$value"
  done
  printf "\n\n"
}

write_theme_env_file() {
  local theme="$1"
  local accent panel omp_config
  if ! omp_config="$(omp_config_for_theme "$theme")"; then
    omp_config="$OMP_LEGACY_CONFIG"
  fi
  if load_theme "$theme"; then
    accent="$_T_accent"
    panel="$_T_panel_rgb"
  else
    accent="#cc44ff"
    panel="204;68;255"
  fi

  mkdir -p "$(dirname "$THEME_ENV_FILE")"
  cat > "$THEME_ENV_FILE" <<EOF
export BOO_THEME="${theme}"
export BOO_ACCENT_COLOR="${accent}"
export BOO_PANEL_COLOR_RGB="${panel}"
export BOO_OMP_CONFIG="${omp_config}"
EOF
}

apply_prompt_theme() {
  local theme="$1"
  local tmp
  local base_preset=""
  local first_preset
  local omp_active_config=""

  local accent chip_cloud_bg go_fg az_fg gcp_fg tf_fg sysinfo_fg
  local frame ink muted
  local left_os_bg left_user_bg left_path_bg left_git_bg left_exec_bg left_root_bg left_root_fg
  local chip_ok_bg chip_ok_fg chip_shell_bg chip_lang_bg chip_infra_bg chip_metric_bg chip_time_bg
  local node_fg python_fg rust_fg kubectl_fg aws_fg time_fg git_dirty_bg git_diverged_bg
  local path_fg exec_fg caret_fg
  local git_dirty_tpl git_diverged_tpl
  if ! load_theme "$theme"; then
    return 1
  fi
  if ! omp_active_config="$(omp_config_for_theme "$theme")"; then
    return 1
  fi

  accent="$_T_accent"
  frame="${_T_ui_dim:-$(blend_color "$_T_bg" "$_T_fg" 430)}"

  left_os_bg="$(blend_color "$_T_bg" "$_T_fg" 140)"
  left_user_bg="$(blend_color "$_T_bg" "$_T_fg" 210)"
  left_path_bg="$(blend_color "$_T_bg" "$_T_fg" 90)"
  left_git_bg="${_T_omp_git_bg}"
  left_exec_bg="$(blend_color "$_T_bg" "$_T_fg" 360)"
  left_root_bg="$_T_pal_1"
  left_root_fg="$(theme_text_color_for_bg "$left_root_bg")"

  ink="$(theme_text_color_for_bg "$left_git_bg")"
  muted="$(readable_color_or_theme_text "$left_os_bg" "${_T_ui_label:-$_T_pal_7}")"
  path_fg="$(readable_color_or_theme_text "$left_path_bg" "$accent")"
  exec_fg="$(readable_color_or_theme_text "$left_exec_bg" "$accent")"
  caret_fg="$(readable_color_or_theme_text "$_T_bg" "$accent")"

  chip_ok_bg="$(blend_color "$_T_bg" "$_T_fg" 320)"
  chip_ok_fg="$(readable_color_or_theme_text "$chip_ok_bg" "$_T_pal_10")"
  chip_shell_bg="$(blend_color "$_T_bg" "$_T_fg" 230)"
  chip_lang_bg="$(blend_color "$_T_bg" "$_T_fg" 260)"
  chip_cloud_bg="${_T_omp_chip_cloud_bg}"
  chip_infra_bg="$(blend_color "$_T_bg" "$_T_fg" 300)"
  chip_metric_bg="$(blend_color "$_T_bg" "$_T_fg" 340)"
  chip_time_bg="$(blend_color "$_T_bg" "$_T_fg" 380)"

  node_fg="$(readable_color_or_theme_text "$chip_lang_bg" "$_T_pal_10")"
  python_fg="$(readable_color_or_theme_text "$chip_lang_bg" "$_T_pal_11")"
  go_fg="$(readable_color_or_theme_text "$chip_lang_bg" "${_T_omp_go_fg}")"
  rust_fg="$(readable_color_or_theme_text "$chip_lang_bg" "$_T_pal_3")"
  kubectl_fg="$(readable_color_or_theme_text "$chip_infra_bg" "$_T_pal_11")"
  aws_fg="$(readable_color_or_theme_text "$chip_cloud_bg" "$_T_pal_11")"
  az_fg="$(readable_color_or_theme_text "$chip_cloud_bg" "${_T_omp_az_fg}")"
  gcp_fg="$(readable_color_or_theme_text "$chip_cloud_bg" "${_T_omp_gcp_fg}")"
  tf_fg="$(readable_color_or_theme_text "$chip_infra_bg" "${_T_omp_tf_fg}")"
  sysinfo_fg="$(readable_color_or_theme_text "$chip_metric_bg" "${_T_omp_sysinfo_fg}")"
  time_fg="$(readable_color_or_theme_text "$chip_time_bg" "${_T_ui_label:-$_T_pal_7}")"
  # Keep git state highlighting subtle so light themes don't get muddy/dark blocks.
  git_dirty_bg="$(blend_color "$left_git_bg" "$_T_pal_3" 240)"
  git_diverged_bg="$(blend_color "$left_git_bg" "$_T_pal_5" 240)"
  git_dirty_tpl="{{ if or (.Working.Changed) (.Staging.Changed) }}${git_dirty_bg}{{ end }}"
  git_diverged_tpl="{{ if and (gt .Ahead 0) (gt .Behind 0) }}${git_diverged_bg}{{ end }}"

  if [[ ! -f "$omp_active_config" ]]; then
    if [[ -f "${OMP_PRESET_DIR}/${theme}.omp.json" ]]; then
      base_preset="${OMP_PRESET_DIR}/${theme}.omp.json"
    elif [[ -f "${OMP_PRESET_DIR}/abyss.omp.json" ]]; then
      base_preset="${OMP_PRESET_DIR}/abyss.omp.json"
    else
      for first_preset in "$OMP_PRESET_DIR"/*.omp.json; do
        [[ -e "$first_preset" ]] || continue
        base_preset="$first_preset"
        break
      done
    fi

    if [[ -z "$base_preset" || ! -f "$base_preset" ]]; then
      printf 'Prompt preset not found in: %s\n' "$OMP_PRESET_DIR" >&2
      printf 'Run installer to install theme presets.\n' >&2
      return 1
    fi

    mkdir -p "$(dirname "$omp_active_config")"
    cp "$base_preset" "$omp_active_config"
  fi

  if ! command -v jq >/dev/null 2>&1; then
    mkdir -p "$(dirname "$OMP_LEGACY_CONFIG")"
    cp "$omp_active_config" "$OMP_LEGACY_CONFIG" 2>/dev/null || true
    return 0
  fi

  tmp="$(mktemp)"
  if ! jq \
    --arg accent "$accent" \
    --arg frame "$frame" \
    --arg ink "$ink" \
    --arg muted "$muted" \
    --arg left_os_bg "$left_os_bg" \
    --arg left_user_bg "$left_user_bg" \
    --arg left_path_bg "$left_path_bg" \
    --arg left_git_bg "$left_git_bg" \
    --arg left_exec_bg "$left_exec_bg" \
    --arg left_root_bg "$left_root_bg" \
    --arg left_root_fg "$left_root_fg" \
    --arg chip_ok_bg "$chip_ok_bg" \
    --arg chip_ok_fg "$chip_ok_fg" \
    --arg chip_shell_bg "$chip_shell_bg" \
    --arg chip_lang_bg "$chip_lang_bg" \
    --arg chip_cloud_bg "$chip_cloud_bg" \
    --arg chip_infra_bg "$chip_infra_bg" \
    --arg chip_metric_bg "$chip_metric_bg" \
    --arg chip_time_bg "$chip_time_bg" \
    --arg path_fg "$path_fg" \
    --arg exec_fg "$exec_fg" \
    --arg caret_fg "$caret_fg" \
    --arg node_fg "$node_fg" \
    --arg python_fg "$python_fg" \
    --arg go_fg "$go_fg" \
    --arg rust_fg "$rust_fg" \
    --arg kubectl_fg "$kubectl_fg" \
    --arg aws_fg "$aws_fg" \
    --arg az_fg "$az_fg" \
    --arg gcp_fg "$gcp_fg" \
    --arg tf_fg "$tf_fg" \
    --arg sysinfo_fg "$sysinfo_fg" \
    --arg time_fg "$time_fg" \
    --arg git_dirty_tpl "$git_dirty_tpl" \
    --arg git_diverged_tpl "$git_diverged_tpl" \
    '
    .palette.frame = $frame
    | .palette.ink = $ink
    | .palette.muted = $muted
    | .palette.accent = $accent
    | .palette.left_os_bg = $left_os_bg
    | .palette.left_user_bg = $left_user_bg
    | .palette.left_path_bg = $left_path_bg
    | .palette.left_git_bg = $left_git_bg
    | .palette.left_exec_bg = $left_exec_bg
    | .palette.left_root_bg = $left_root_bg
    | .palette.left_root_fg = $left_root_fg
    | .palette.chip_ok_bg = $chip_ok_bg
    | .palette.chip_ok_fg = $chip_ok_fg
    | .palette.chip_shell_bg = $chip_shell_bg
    | .palette.chip_lang_bg = $chip_lang_bg
    | .palette.chip_cloud_bg = $chip_cloud_bg
    | .palette.chip_infra_bg = $chip_infra_bg
    | .palette.chip_metric_bg = $chip_metric_bg
    | .palette.chip_time_bg = $chip_time_bg
    | (.blocks[].segments[] | select(.type=="path")).foreground = $path_fg
    | (.blocks[].segments[] | select(.type=="executiontime")).foreground = $exec_fg
    | (.blocks[].segments[] | select(.type=="node")).foreground = $node_fg
    | (.blocks[].segments[] | select(.type=="python")).foreground = $python_fg
    | (.blocks[].segments[] | select(.type=="go")).foreground = $go_fg
    | (.blocks[].segments[] | select(.type=="rust")).foreground = $rust_fg
    | (.blocks[].segments[] | select(.type=="kubectl")).foreground = $kubectl_fg
    | (.blocks[].segments[] | select(.type=="aws")).foreground = $aws_fg
    | (.blocks[].segments[] | select(.type=="az")).foreground = $az_fg
    | (.blocks[].segments[] | select(.type=="gcp")).foreground = $gcp_fg
    | (.blocks[].segments[] | select(.type=="terraform")).foreground = $tf_fg
    | (.blocks[].segments[] | select(.type=="sysinfo")).foreground = $sysinfo_fg
    | (.blocks[].segments[] | select(.type=="time")).foreground = $time_fg
    | (.blocks[].segments[] | select(.type=="status" and .style=="plain")).foreground = $caret_fg
    | .transient_prompt.foreground = $caret_fg
    | (.blocks[].segments[] | select(.type=="git").background_templates[0]) = $git_dirty_tpl
    | (.blocks[].segments[] | select(.type=="git").background_templates[1]) = $git_diverged_tpl
    ' \
    "$omp_active_config" > "$tmp"; then
    rm -f "$tmp"
    printf 'Failed to patch prompt config: %s\n' "$omp_active_config" >&2
    return 1
  fi
  mv "$tmp" "$omp_active_config"
  mkdir -p "$(dirname "$OMP_LEGACY_CONFIG")"
  cp "$omp_active_config" "$OMP_LEGACY_CONFIG" 2>/dev/null || true
  return 0
}

is_boo_ghostty_config_file() {
  local file="$1"
  [[ -f "$file" ]] || return 1

  if grep -qF "$BOO_GHOSTTY_MARKER" "$file"; then
    return 0
  fi

  # Legacy Boo installs may not have the explicit marker.
  if grep -qF "theme = Phala Green Dark" "$file" \
    && grep -qF "window-padding-color = extend" "$file" \
    && grep -qF "shell-integration = zsh" "$file"; then
    return 0
  fi

  return 1
}

collect_ghostty_targets() {
  ghostty_targets=()

  if [[ "$UNAME_S" == "Darwin" ]]; then
    # Prefer whichever config Ghostty is already using (non-empty file).
    if [[ -s "$GHOSTTY_CONFIG_MAC" ]]; then
      ghostty_targets+=("$GHOSTTY_CONFIG_MAC")
    fi
    if [[ -s "$GHOSTTY_CONFIG_PRIMARY" ]]; then
      ghostty_targets+=("$GHOSTTY_CONFIG_PRIMARY")
    fi

    if [[ "${#ghostty_targets[@]}" -eq 0 ]]; then
      if [[ -f "$GHOSTTY_CONFIG_MAC" ]]; then
        ghostty_targets+=("$GHOSTTY_CONFIG_MAC")
      elif [[ -f "$GHOSTTY_CONFIG_PRIMARY" ]]; then
        ghostty_targets+=("$GHOSTTY_CONFIG_PRIMARY")
      else
        mkdir -p "$(dirname "$GHOSTTY_CONFIG_PRIMARY")"
        touch "$GHOSTTY_CONFIG_PRIMARY"
        ghostty_targets+=("$GHOSTTY_CONFIG_PRIMARY")
      fi
    fi
    return
  fi

  mkdir -p "$(dirname "$GHOSTTY_CONFIG_PRIMARY")"
  if [[ ! -f "$GHOSTTY_CONFIG_PRIMARY" ]]; then
    touch "$GHOSTTY_CONFIG_PRIMARY"
  fi
  ghostty_targets+=("$GHOSTTY_CONFIG_PRIMARY")
}

upsert_key() {
  local file="$1"
  local key="$2"
  local value="$3"
  local tmp
  tmp="$(mktemp)"

  awk -v key="$key" -v value="$value" '
    BEGIN { re = "^[[:space:]]*" key "[[:space:]]*="; done = 0 }
    $0 ~ re {
      if (!done) {
        print key " = " value
        done = 1
      }
      next
    }
    { print }
    END {
      if (!done) {
        print key " = " value
      }
    }
  ' "$file" > "$tmp"

  mv "$tmp" "$file"
}

emit_standard_palette_16_255() {
  local levels=(00 5f 87 af d7 ff)
  local r g b idx gray_step gray_value hex

  idx=16
  for r in "${levels[@]}"; do
    for g in "${levels[@]}"; do
      for b in "${levels[@]}"; do
        printf 'palette = %d=#%s%s%s\n' "$idx" "$r" "$g" "$b"
        idx=$((idx + 1))
      done
    done
  done

  for gray_step in {0..23}; do
    gray_value=$((8 + gray_step * 10))
    printf -v hex '%02x' "$gray_value"
    printf 'palette = %d=#%s%s%s\n' $((232 + gray_step)) "$hex" "$hex" "$hex"
  done
}

theme_palette_lines() {
  local theme="$1"
  local i key
  if ! load_theme "$theme"; then
    return 1
  fi

  for i in {0..15}; do
    key="_T_pal_${i}"
    printf 'palette = %d=%s\n' "$i" "${!key}"
  done
  emit_standard_palette_16_255
}

replace_palette_lines() {
  local file="$1"
  local theme="$2"
  local tmp palette_tmp

  tmp="$(mktemp)"
  palette_tmp="$(mktemp)"
  theme_palette_lines "$theme" > "$palette_tmp"

  awk -v palette_file="$palette_tmp" '
    BEGIN { inserted = 0 }
    /^[[:space:]]*palette[[:space:]]*=/ { next }
    {
      print
      if (!inserted && $0 ~ /^[[:space:]]*selection-foreground[[:space:]]*=/) {
        while ((getline line < palette_file) > 0) {
          print line
        }
        close(palette_file)
        inserted = 1
      }
    }
    END {
      if (!inserted) {
        while ((getline line < palette_file) > 0) {
          print line
        }
        close(palette_file)
      }
    }
  ' "$file" > "$tmp"

  mv "$tmp" "$file"
  rm -f "$palette_tmp"
}

current_opacity() {
  collect_ghostty_targets
  local file line value
  for file in "${ghostty_targets[@]}"; do
    line="$(grep -m1 -E '^[[:space:]]*background-opacity[[:space:]]*=' "$file" || true)"
    if [[ -n "$line" ]]; then
      value="$(printf '%s\n' "$line" | sed -E 's/^[^=]+= *//; s/[[:space:]]+$//')"
      printf '%s\n' "$value"
      return
    fi
  done
  printf '%s\n' "$DEFAULT_OPACITY"
}

set_opacity_value() {
  local value="$1"
  local file

  collect_ghostty_targets
  for file in "${ghostty_targets[@]}"; do
    upsert_key "$file" "background-opacity" "$value"
  done
}

read_ghostty_key_value() {
  local key="$1"
  local default_value="${2:-}"
  local file line value

  collect_ghostty_targets
  for file in "${ghostty_targets[@]}"; do
    line="$(grep -m1 -E "^[[:space:]]*${key}[[:space:]]*=" "$file" || true)"
    if [[ -n "$line" ]]; then
      value="$(printf '%s\n' "$line" | sed -E 's/^[^=]+= *//; s/[[:space:]]+$//')"
      printf '%s\n' "$value"
      return 0
    fi
  done

  if [[ -n "$default_value" ]]; then
    printf '%s\n' "$default_value"
    return 0
  fi
  return 1
}

current_font_family() {
  read_ghostty_key_value "font-family" "JetBrainsMono Nerd Font"
}

current_font_size() {
  read_ghostty_key_value "font-size" "14"
}

set_font_family_value() {
  local family="$1"
  local file

  collect_ghostty_targets
  for file in "${ghostty_targets[@]}"; do
    upsert_key "$file" "font-family" "$family"
  done
}

set_font_size_value() {
  local size="$1"
  local file

  collect_ghostty_targets
  for file in "${ghostty_targets[@]}"; do
    upsert_key "$file" "font-size" "$size"
  done
}

resolve_font_preset_family() {
  local preset
  preset="$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')"
  case "$preset" in
    jetbrains|jetbrainsmono|jb) printf '%s\n' 'JetBrainsMono Nerd Font' ;;
    fira|firacode) printf '%s\n' 'FiraCode Nerd Font' ;;
    meslo|meslolgs) printf '%s\n' 'MesloLGS Nerd Font' ;;
    hack) printf '%s\n' 'Hack Nerd Font' ;;
    caskaydia|cascadia) printf '%s\n' 'CaskaydiaCove Nerd Font' ;;
    iosevka|iosevkaterm) printf '%s\n' 'IosevkaTerm Nerd Font' ;;
    *) return 1 ;;
  esac
}

is_font_size_token() {
  local token="$1"
  [[ "$token" =~ ^[0-9]+([.][0-9]+)?$ ]]
}

normalize_font_size() {
  local input="$1"
  local valid=0

  if ! is_font_size_token "$input"; then
    printf 'Invalid font size: %s\n' "$input" >&2
    printf 'Use a value between 8 and 72 (example: 14 or 15.5).\n' >&2
    exit 1
  fi

  if awk -v n="$input" 'BEGIN { if (n + 0 == n && n >= 8 && n <= 72) exit 0; exit 1 }'; then
    valid=1
  fi

  if [[ "$valid" -ne 1 ]]; then
    printf 'Invalid font size: %s\n' "$input" >&2
    printf 'Use a value between 8 and 72 (example: 14 or 15.5).\n' >&2
    exit 1
  fi

  printf '%s\n' "$input"
}

reload_keybind_dispatch_mode() {
  local trigger_line trigger core
  local has_cmd=0 has_shift=0 key=""
  local -a parts
  local token

  if ! command -v ghostty >/dev/null 2>&1; then
    printf 'cmd-shift-comma\n'
    return
  fi

  trigger_line="$(ghostty +list-keybinds 2>/dev/null | sed -nE 's/^[[:space:]]*keybind[[:space:]]*=[[:space:]]*([^=]+)=reload_config[[:space:]]*$/\1/p' | head -n1 | tr -d '[:space:]' || true)"
  if [[ -z "$trigger_line" ]]; then
    printf 'cmd-shift-comma\n'
    return
  fi

  trigger="$(printf '%s' "$trigger_line" | tr '[:upper:]' '[:lower:]')"
  core="${trigger##*:}"
  IFS='+' read -r -a parts <<< "$core"

  for token in "${parts[@]}"; do
    case "$token" in
      super|cmd|command)
        has_cmd=1
        ;;
      shift)
        has_shift=1
        ;;
      ,|comma)
        key="comma"
        ;;
    esac
  done

  if [[ "$has_cmd" -eq 1 && "$key" == "comma" ]]; then
    if [[ "$has_shift" -eq 1 ]]; then
      printf 'cmd-shift-comma\n'
    else
      printf 'cmd-comma\n'
    fi
    return
  fi

  printf 'unsupported:%s\n' "$trigger_line"
}

unsafe_reload_via_keystroke() {
  local result dispatch_mode
  UNSAFE_RELOAD_REASON=""

  if [[ "$UNAME_S" != "Darwin" ]]; then
    UNSAFE_RELOAD_REASON="not-darwin"
    return 1
  fi
  if ! command -v osascript >/dev/null 2>&1; then
    UNSAFE_RELOAD_REASON="no-osascript"
    return 1
  fi

  dispatch_mode="$(reload_keybind_dispatch_mode)"
  if [[ "$dispatch_mode" == unsupported:* ]]; then
    UNSAFE_RELOAD_REASON="unsupported-keybind:${dispatch_mode#unsupported:}"
    return 1
  fi

  result="$(osascript - "$dispatch_mode" <<'APPLESCRIPT' 2>/dev/null || true
on run argv
set bundleId to "com.mitchellh.ghostty"
set dispatchMode to "cmd-shift-comma"
if (count of argv) > 0 then
  set dispatchMode to item 1 of argv
end if

try
  tell application id bundleId to activate
on error
  -- Continue and try process-based focus fallback.
end try

delay 0.20

try
  tell application "System Events"
    if not (exists (first process whose bundle identifier is bundleId)) then
      return "not-running"
    end if
    set ghosttyProc to first process whose bundle identifier is bundleId
    set frontmost of ghosttyProc to true
  end tell
on error errMsg number errNum
  return "process-failed:" & errNum
end try

delay 0.20

try
  tell application "System Events"
    set frontProc to first process whose frontmost is true
    if bundle identifier of frontProc is not bundleId then
      return "not-frontmost"
    end if
    if dispatchMode is "cmd-comma" then
      keystroke "," using {command down}
    else
      keystroke "," using {command down, shift down}
    end if
  end tell
  return "ok"
on error errMsg number errNum
  return "keystroke-failed:" & errNum
end try
end run
APPLESCRIPT
)"

  if [[ "$result" == "ok" ]]; then
    return 0
  fi

  if [[ -z "$result" ]]; then
    UNSAFE_RELOAD_REASON="osascript-error"
    return 1
  fi

  case "$result" in
    not-running)
      UNSAFE_RELOAD_REASON="not-running"
      ;;
    check-failed)
      UNSAFE_RELOAD_REASON="check-failed"
      ;;
    process-failed:*|not-frontmost)
      UNSAFE_RELOAD_REASON="$result"
      ;;
    keystroke-failed:*)
      UNSAFE_RELOAD_REASON="$result"
      ;;
    *)
      UNSAFE_RELOAD_REASON="unknown"
      ;;
  esac
  return 1
}

cmd_reload() {
  local option="${1:-}"
  local unsafe=0
  local _t _a _rgb _ca _cb _cd _cv _cr
  _t="$(read_theme_file)"
  _init_ui "$_t"

  case "$option" in
    ''|safe|--safe)
      ;;
    unsafe|--unsafe|-u)
      unsafe=1
      ;;
    *)
      printf 'Invalid reload option: %s\n' "$option" >&2
      printf 'Usage: boo reload [--unsafe]\n' >&2
      exit 1
      ;;
  esac

  if [[ "${BOO_NO_AUTO_APPLY:-0}" == "1" ]]; then
    return 0
  fi

  if (( unsafe == 1 )); then
    if unsafe_reload_via_keystroke; then
      return 0
    else
      printf "\n  ${_cd}↺  press Cmd+Shift+, in Ghostty to apply${_cr}\n\n"
      return 1
    fi
  fi

  printf "\n  ${_cd}↺${_cr}  ${_cv}config saved${_cr}\n"
  printf "  ${_cd}   boo reload --unsafe  ·  Cmd+Shift+, to apply${_cr}\n\n"
}

resolve_opacity() {
  local input="$1"
  local resolved

  case "$input" in
    solid)
      printf '1.00\n'
      return
      ;;
    glass)
      printf '0.92\n'
      return
      ;;
    *)
      ;;
  esac

  if [[ ! "$input" =~ ^(0(\.[0-9]+)?|1(\.0+)?)$ ]]; then
    printf 'Invalid opacity: %s\n' "$input" >&2
    printf 'Use a value between 0.30 and 1.00, or: glass, solid\n' >&2
    exit 1
  fi

  resolved="$(awk -v n="$input" 'BEGIN {
    if (n + 0 == n && n >= 0.30 && n <= 1.00) {
      printf "%.2f", n
      exit 0
    }
    exit 1
  }')" || {
    printf 'Invalid opacity: %s\n' "$input" >&2
    printf 'Use a value between 0.30 and 1.00, or: glass, solid\n' >&2
    exit 1
  }

  printf '%s\n' "$resolved"
}

apply_theme() {
  local theme="$1"
  local theme_name background foreground cursor_color cursor_text selection_bg selection_fg
  local file

  if ! load_theme "$theme"; then
    printf 'Invalid theme: %s\n' "$theme" >&2
    if [[ -n "${_THEME_LOAD_ERROR:-}" ]]; then
      printf '%s\n' "$_THEME_LOAD_ERROR" >&2
    fi
    printf 'Use: %s\n' "$(theme_names_pipe_separated | sed 's/|/, /g')" >&2
    exit 1
  fi

  theme_name="Phala Green Dark"
  background="$_T_bg"
  foreground="$_T_fg"
  cursor_color="$_T_cursor"
  cursor_text="$_T_cursor_text"
  selection_bg="$_T_selection_bg"
  selection_fg="$_T_selection_fg"

  collect_ghostty_targets
  for file in "${ghostty_targets[@]}"; do
    upsert_key "$file" "theme" "$theme_name"
    upsert_key "$file" "background" "$background"
    upsert_key "$file" "foreground" "$foreground"
    upsert_key "$file" "cursor-color" "$cursor_color"
    upsert_key "$file" "cursor-text" "$cursor_text"
    upsert_key "$file" "selection-background" "$selection_bg"
    upsert_key "$file" "selection-foreground" "$selection_fg"
    replace_palette_lines "$file" "$theme"
  done

  apply_prompt_theme "$theme" || true
  write_theme_env_file "$theme"
  write_theme_file "$theme"
}

cmd_mode() {
  local arg="${1:-}"
  local _t _a _rgb _ca _cb _cd _cv _cr
  _t="$(read_theme_file)"
  _init_ui "$_t"

  case "$arg" in
    '')
      printf "\n  ${_cd}mode${_cr}    ${_cb}${_ca}%s${_cr}\n\n" "$(read_mode)"
      ;;
    full|private|1)
      write_mode_file "1"
      printf "\n  ${_ca}✓${_cr}  ${_cv}mode  →  full${_cr}\n\n"
      print_shell_apply_hint
      ;;
    public|safe|0)
      write_mode_file "0"
      printf "\n  ${_ca}✓${_cr}  ${_cv}mode  →  public${_cr}\n\n"
      print_shell_apply_hint
      ;;
    *)
      printf 'Invalid mode: %s\n' "$arg" >&2
      printf 'Usage: boo mode [full|public]\n' >&2
      exit 1
      ;;
  esac
}

cmd_prompt() {
  local action="${1:-}"
  local backend="${2:-}"
  local configured effective

  case "$action" in
    ''|show|status)
      configured="$(read_prompt_backend)"
      effective="$(effective_prompt_backend)"
      local _t
      _t="$(read_theme_file)"
      _init_ui "$_t"
      if [[ "$configured" == "$effective" ]]; then
        printf "\n  ${_cd}prompt${_cr}    ${_cb}${_ca}%s${_cr}\n\n" "$configured"
      else
        printf "\n  ${_cd}prompt${_cr}    ${_cb}${_ca}%s${_cr}  ${_cd}active: native — oh-my-posh not found${_cr}\n\n" "$configured"
      fi
      ;;
    list)
      local _t
      _t="$(read_theme_file)"
      _init_ui "$_t"
      printf "\n  ${_cd}PROMPT BACKENDS${_cr}\n\n"
      printf "  ${_cb}${_ca}native${_cr}    ${_cv}built-in zsh prompt${_cr}\n"
      printf "  ${_cb}${_ca}omp${_cr}       ${_cv}oh-my-posh prompt engine${_cr}\n"
      printf "\n"
      ;;
    set)
      if [[ -z "$backend" ]]; then
        printf 'Usage: boo prompt set <native|omp>\n' >&2
        exit 1
      fi
      case "$backend" in
        native|omp)
          write_prompt_backend "$backend"
          local _t
          _t="$(read_theme_file)"
          _init_ui "$_t"
          printf "\n  ${_ca}✓${_cr}  ${_cv}prompt  →  %s${_cr}\n" "$backend"
          if [[ "$backend" == "omp" ]] && ! command -v oh-my-posh >/dev/null 2>&1; then
            printf "  ${_cd}  oh-my-posh not found — will fall back to native${_cr}\n"
          fi
          printf "\n"
          print_shell_apply_hint
          ;;
        *)
          printf 'Invalid prompt backend: %s\n' "$backend" >&2
          printf 'Use: native, omp\n' >&2
          exit 1
          ;;
      esac
      ;;
    native|omp)
      write_prompt_backend "$action"
      local _t
      _t="$(read_theme_file)"
      _init_ui "$_t"
      printf "\n  ${_ca}✓${_cr}  ${_cv}prompt  →  %s${_cr}\n" "$action"
      if [[ "$action" == "omp" ]] && ! command -v oh-my-posh >/dev/null 2>&1; then
        printf "  ${_cd}  oh-my-posh not found — will fall back to native${_cr}\n"
      fi
      printf "\n"
      print_shell_apply_hint
      ;;
    *)
      printf 'Invalid prompt command: %s\n' "$action" >&2
      printf 'Usage: boo prompt [show|list|set <native|omp>|native|omp]\n' >&2
      exit 1
      ;;
  esac
}

cmd_theme_create() {
  local accent="" name=""

  # parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --accent) accent="${2:-}"; shift 2 ;;
      --name)   name="${2:-}";   shift 2 ;;
      *)        shift ;;
    esac
  done

  local _t
  _t="$(read_theme_file)"
  _init_ui "$_t"

  printf "\n"

  # interactive prompts if flags not provided
  if [[ -z "$accent" ]]; then
    printf "  ${_cv}accent${_cr}    ${_cd}hex color e.g. #ff6a1a${_cr}\n"
    printf "  ${_ca}›${_cr} "
    read -r accent
    accent="$(trim_ws "$accent")"
  fi

  # validate accent
  if [[ ! "$accent" =~ ^#[0-9A-Fa-f]{6}$ ]]; then
    printf "\n  ${_cv}invalid hex — must be #RRGGBB${_cr}\n\n" >&2
    exit 1
  fi

  if [[ -z "$name" ]]; then
    printf "  ${_cv}name${_cr}      ${_cd}lowercase, a-z 0-9 dashes${_cr}\n"
    printf "  ${_ca}›${_cr} "
    read -r name
    name="$(trim_ws "$name")"
  fi

  # validate name
  if [[ ! "$name" =~ ^[a-z0-9][a-z0-9_-]*$ ]]; then
    printf "\n  ${_cv}invalid name — use lowercase a-z, 0-9, dashes${_cr}\n\n" >&2
    exit 1
  fi

  # check collision
  if theme_file_for_name "$name" >/dev/null 2>&1; then
    printf "\n  ${_cv}theme '%s' already exists${_cr}\n\n" "$name" >&2
    exit 1
  fi

  # generate
  local tmpfile
  tmpfile="$(mktemp)"
  generate_theme "$accent" "$name" > "$tmpfile"

  # validate by loading it
  mkdir -p "$THEMES_DIR"
  cp "$tmpfile" "${THEMES_DIR}/${name}.theme"
  rm -f "$tmpfile"

  _LOADED_THEME=""
  if ! load_theme "$name"; then
    rm -f "${THEMES_DIR}/${name}.theme"
    printf "\n  ${_cv}generated theme failed validation: %s${_cr}\n\n" "$_THEME_LOAD_ERROR" >&2
    exit 1
  fi

  # preview
  local accent_rgb
  accent_rgb="$(hex_to_rgb "$accent")"
  printf "\n  ${_cb}\033[38;2;%sm%s${_cr}  ${_cd}%s${_cr}\n\n" "$accent_rgb" "$name" "$_T_description"
  print_theme_preview "$name"

  printf "  ${_cv}saved to${_cr} ${_cd}%s${_cr}\n\n" "${THEMES_DIR}/${name}.theme"

  # ask to apply
  printf "  ${_cv}apply now?${_cr} ${_cd}[y/n]${_cr} "
  local reply
  read -r reply
  case "$reply" in
    [yY]|[yY]es)
      apply_theme "$name"
      print_theme_applied_card "$name"
      cmd_reload > /dev/null 2>&1 || true
      ;;
    *)
      printf "\n  ${_cd}theme saved — apply later with:${_cr} ${_ca}boo theme %s${_cr}\n\n" "$name"
      ;;
  esac
}

is_builtin_theme() {
  local name="$1" file
  file="$(theme_file_for_name "$name" 2>/dev/null)" || return 1
  head -n1 "$file" | grep -q '^# builtin'
}

cmd_theme_delete() {
  local name="${1:-}"
  local _t
  _t="$(read_theme_file)"
  _init_ui "$_t"

  if [[ -z "$name" ]]; then
    local tname accent_rgb count=0
    printf "\n  ${_cd}DELETABLE THEMES${_cr}\n\n"
    while IFS= read -r tname; do
      [[ -n "$tname" ]] || continue
      is_builtin_theme "$tname" && continue
      if load_theme "$tname" 2>/dev/null; then
        accent_rgb="$(hex_to_rgb "$_T_accent" 2>/dev/null || printf '180;180;180')"
        printf "  ${_cb}\033[38;2;%sm%-10s${_cr}  ${_cv}%s${_cr}\n" "$accent_rgb" "$tname" "$_T_description"
        count=$((count + 1))
      fi
    done < <(list_theme_names)
    if (( count == 0 )); then
      printf "  ${_cd}no user-created themes to delete${_cr}\n"
    fi
    printf "\n"
    return
  fi

  if ! theme_file_for_name "$name" >/dev/null 2>&1; then
    printf "\n  ${_cv}theme '%s' not found${_cr}\n\n" "$name" >&2
    exit 1
  fi

  if is_builtin_theme "$name"; then
    printf "\n  ${_cv}cannot delete built-in theme '%s'${_cr}\n\n" "$name" >&2
    exit 1
  fi

  local file="${THEMES_DIR}/${name}.theme"
  if [[ ! -f "$file" ]]; then
    printf "\n  ${_cv}theme '%s' not found in user themes${_cr}\n\n" "$name" >&2
    exit 1
  fi

  local active
  active="$(read_theme_file)"
  local is_active=0
  if [[ "$active" == "$name" ]]; then
    is_active=1
    printf "\n  ${_cd}'%s' is the active theme — will switch to %s after deleting${_cr}\n" "$name" "$DEFAULT_THEME"
  fi

  printf "\n  ${_cv}delete theme '%s'?${_cr} ${_cd}[y/n]${_cr} " "$name"
  local reply
  read -r reply
  case "$reply" in
    [yY]|[yY]es)
      rm -f "$file"
      printf "  ${_ca}✓${_cr}  ${_cv}deleted %s${_cr}\n" "$name"
      if (( is_active )); then
        _LOADED_THEME=""
        apply_theme "$DEFAULT_THEME"
        printf "  ${_ca}✓${_cr}  ${_cv}switched to %s${_cr}\n" "$DEFAULT_THEME"
        cmd_reload > /dev/null 2>&1 || true
      fi
      printf "\n"
      ;;
    *)
      printf "  ${_cd}cancelled${_cr}\n\n"
      ;;
  esac
}

cmd_theme() {
  local action="${1:-}"
  local theme="${2:-}"
  local theme_options

  case "$action" in
    '')
      local _t
      _t="$(read_theme_file)"
      _init_ui "$_t"
      printf "\n  ${_cd}theme${_cr}    ${_cb}${_ca}%s${_cr}\n\n" "$_t"
      ;;
    create)
      shift || true
      cmd_theme_create "$@"
      return
      ;;
    delete|remove)
      cmd_theme_delete "$theme"
      return
      ;;
    select|choose|pick)
      cmd_theme_select
      return
      ;;
    list)
      local _t name accent_rgb count mode palette row
      local -a dark_rows=()
      local -a light_rows=()
      local -a invalid_rows=()
      _t="$(read_theme_file)"
      _init_ui "$_t"
      printf "\n  ${_cd}THEMES${_cr}\n"
      count=0
      while IFS= read -r name; do
        [[ -n "$name" ]] || continue
        count=$((count + 1))
        if ! load_theme "$name"; then
          invalid_rows+=("  ${_cb}${name}${_cr}  ${_cv}[invalid theme file]${_cr}")
          continue
        fi
        accent_rgb="$(hex_to_rgb "$_T_accent" 2>/dev/null || printf '204;68;255')"
        palette="$(theme_palette_strip_main)"
        mode="$(theme_mode_for_bg "$_T_bg")"
        if [[ "$mode" == "light" ]]; then
          printf -v row "  ${_cb}\033[38;2;%sm%-10s${_cr}      %s" "$accent_rgb" "$name" "$palette"
          light_rows+=("$row")
        else
          printf -v row "  ${_cb}\033[38;2;%sm%-10s${_cr}      %s" "$accent_rgb" "$name" "$palette"
          dark_rows+=("$row")
        fi
      done < <(list_theme_names)
      if (( count == 0 )); then
        printf "\n  ${_cd}No themes found in %s${_cr}\n\n" "$THEMES_DIR"
        return
      fi

      local idx
      if (( ${#dark_rows[@]} > 0 )); then
        printf "\n  ${_cl}DARK${_cr}\n\n"
        for (( idx = 0; idx < ${#dark_rows[@]}; idx++ )); do
          printf "%b\n" "${dark_rows[$idx]}"
          if (( idx + 1 < ${#dark_rows[@]} )); then
            printf "\n"
          fi
        done
      fi

      if (( ${#light_rows[@]} > 0 )); then
        printf "\n  ${_cl}LIGHT${_cr}\n\n"
        for (( idx = 0; idx < ${#light_rows[@]}; idx++ )); do
          printf "%b\n" "${light_rows[$idx]}"
          if (( idx + 1 < ${#light_rows[@]} )); then
            printf "\n"
          fi
        done
      fi

      if (( ${#invalid_rows[@]} > 0 )); then
        printf "\n  ${_cv}INVALID${_cr}\n\n"
        for (( idx = 0; idx < ${#invalid_rows[@]}; idx++ )); do
          printf "%b\n" "${invalid_rows[$idx]}"
          if (( idx + 1 < ${#invalid_rows[@]} )); then
            printf "\n"
          fi
        done
      fi
      printf "\n"
      ;;
    set)
      theme_options="$(theme_names_pipe_separated)"
      if [[ -z "$theme" ]]; then
        printf 'Usage: boo theme set <%s>\n' "$theme_options" >&2
        exit 1
      fi
      if ! is_valid_theme "$theme"; then
        if theme_file_for_name "$theme" >/dev/null 2>&1; then
          printf 'Invalid theme: %s\n' "$theme" >&2
          if [[ -n "${_THEME_LOAD_ERROR:-}" ]]; then
            printf '%s\n' "$_THEME_LOAD_ERROR" >&2
          fi
        else
          printf 'Invalid theme: %s\n' "$theme" >&2
        fi
        printf 'Use: %s\n' "$(printf '%s' "$theme_options" | sed 's/|/, /g')" >&2
        exit 1
      fi
      apply_theme "$theme"
      print_theme_applied_card "$theme"
      cmd_reload > /dev/null 2>&1 || true
      ;;
    *)
      if is_valid_theme "$action"; then
        apply_theme "$action"
        print_theme_applied_card "$action"
        cmd_reload > /dev/null 2>&1 || true
      elif theme_file_for_name "$action" >/dev/null 2>&1; then
        printf 'Invalid theme: %s\n' "$action" >&2
        if [[ -n "${_THEME_LOAD_ERROR:-}" ]]; then
          printf '%s\n' "$_THEME_LOAD_ERROR" >&2
        fi
        exit 1
      else
        printf 'Invalid theme command: %s\n' "$action" >&2
        printf 'Usage: boo theme [list|select|set <name>|<name>]\n' >&2
        exit 1
      fi
      ;;
  esac
}

cmd_font() {
  local action="${1:-}"
  local preset_family family size
  local _t _a _rgb _ca _cb _cd _cv _cr
  _t="$(read_theme_file)"
  _init_ui "$_t"

  case "$action" in
    ''|show|status)
      printf "\n  ${_cd}family${_cr}    ${_cb}${_ca}%s${_cr}\n" "$(current_font_family)"
      printf "  ${_cd}size${_cr}      ${_cb}${_ca}%s${_cr}\n\n" "$(current_font_size)"
      ;;
    list)
      printf "\n  ${_cd}FONTS${_cr}\n\n"
      printf "  ${_cb}${_ca}jetbrains${_cr}    ${_cv}JetBrainsMono Nerd Font${_cr}\n"
      printf "  ${_cb}${_ca}fira${_cr}         ${_cv}FiraCode Nerd Font${_cr}\n"
      printf "  ${_cb}${_ca}meslo${_cr}        ${_cv}MesloLGS Nerd Font${_cr}\n"
      printf "  ${_cb}${_ca}hack${_cr}         ${_cv}Hack Nerd Font${_cr}\n"
      printf "  ${_cb}${_ca}caskaydia${_cr}    ${_cv}CaskaydiaCove Nerd Font${_cr}\n"
      printf "  ${_cb}${_ca}iosevka${_cr}      ${_cv}IosevkaTerm Nerd Font${_cr}\n"
      printf "\n"
      ;;
    set)
      if [[ $# -lt 2 ]]; then
        printf 'Usage: boo font set <preset>|family <name>|size <value>\n' >&2
        exit 1
      fi
      case "${2:-}" in
        family)
          if [[ $# -lt 3 ]]; then
            printf 'Usage: boo font set family <name>\n' >&2
            exit 1
          fi
          family="${*:3}"
          set_font_family_value "$family"
          printf "\n  ${_ca}✓${_cr}  ${_cv}font family  →  %s${_cr}\n\n" "$family"
          cmd_reload --unsafe || true
          ;;
        size)
          if [[ $# -lt 3 ]]; then
            printf 'Usage: boo font set size <value>\n' >&2
            exit 1
          fi
          size="$(normalize_font_size "${3:-}")"
          set_font_size_value "$size"
          printf "\n  ${_ca}✓${_cr}  ${_cv}font size  →  %s${_cr}\n\n" "$size"
          cmd_reload --unsafe || true
          ;;
        *)
          if preset_family="$(resolve_font_preset_family "${2:-}")"; then
            set_font_family_value "$preset_family"
            printf "\n  ${_ca}✓${_cr}  ${_cv}font  →  %s${_cr}\n\n" "$preset_family"
            cmd_reload --unsafe || true
          else
            family="${*:2}"
            set_font_family_value "$family"
            printf "\n  ${_ca}✓${_cr}  ${_cv}font family  →  %s${_cr}\n\n" "$family"
            cmd_reload --unsafe || true
          fi
          ;;
      esac
      ;;
    family)
      if [[ $# -lt 2 ]]; then
        printf 'Usage: boo font family <name>\n' >&2
        exit 1
      fi
      family="${*:2}"
      set_font_family_value "$family"
      printf "\n  ${_ca}✓${_cr}  ${_cv}font family  →  %s${_cr}\n\n" "$family"
      cmd_reload --unsafe || true
      ;;
    size)
      if [[ $# -lt 2 ]]; then
        printf 'Usage: boo font size <value>\n' >&2
        exit 1
      fi
      size="$(normalize_font_size "${2:-}")"
      set_font_size_value "$size"
      printf "\n  ${_ca}✓${_cr}  ${_cv}font size  →  %s${_cr}\n\n" "$size"
      cmd_reload --unsafe || true
      ;;
    *)
      if preset_family="$(resolve_font_preset_family "$action")"; then
        set_font_family_value "$preset_family"
        printf "\n  ${_ca}✓${_cr}  ${_cv}font  →  %s${_cr}\n\n" "$preset_family"
        cmd_reload --unsafe || true
      elif is_font_size_token "$action"; then
        size="$(normalize_font_size "$action")"
        set_font_size_value "$size"
        printf "\n  ${_ca}✓${_cr}  ${_cv}font size  →  %s${_cr}\n\n" "$size"
        cmd_reload --unsafe || true
      else
        family="$*"
        set_font_family_value "$family"
        printf "\n  ${_ca}✓${_cr}  ${_cv}font family  →  %s${_cr}\n\n" "$family"
        cmd_reload --unsafe || true
      fi
      ;;
  esac
}

cmd_opacity() {
  local arg="${1:-}"
  local resolved
  local _t _a _rgb _ca _cb _cd _cv _cr
  _t="$(read_theme_file)"
  _init_ui "$_t"

  case "$arg" in
    '')
      printf "\n  ${_cd}opacity${_cr}    ${_cb}${_ca}%s${_cr}\n\n" "$(current_opacity)"
      ;;
    *)
      resolved="$(resolve_opacity "$arg")"
      set_opacity_value "$resolved"
      printf "\n  ${_ca}✓${_cr}  ${_cv}opacity  →  %s${_cr}\n\n" "$resolved"
      cmd_reload --unsafe || true
      ;;
  esac
}

cmd_preview() {
  local target=""
  local token
  local plain=0
  local themes=()
  local theme
  local usage

  usage="$(theme_names_pipe_separated)"
  for token in "$@"; do
    case "$token" in
      '' )
        ;;
      --plain|-p)
        plain=1
        ;;
      all)
        if [[ -n "$target" ]]; then
          printf 'Only one preview target can be used at a time.\n' >&2
          printf 'Usage: boo preview <%s|all> [--plain]\n' "$usage" >&2
          exit 1
        fi
        target="$token"
        ;;
      *)
        if is_valid_theme "$token" || theme_file_for_name "$token" >/dev/null 2>&1; then
          if [[ -n "$target" ]]; then
            printf 'Only one preview target can be used at a time.\n' >&2
            printf 'Usage: boo preview <%s|all> [--plain]\n' "$usage" >&2
            exit 1
          fi
          target="$token"
        else
          printf 'Invalid preview option/target: %s\n' "$token" >&2
          printf 'Usage: boo preview <%s|all> [--plain]\n' "$usage" >&2
          exit 1
        fi
        ;;
    esac
  done

  if [[ -z "$target" ]]; then
    printf 'Usage: boo preview <%s|all> [--plain]\n' "$usage"
    return
  fi

  case "$target" in
    all)
      while IFS= read -r theme; do
        [[ -n "$theme" ]] || continue
        themes+=("$theme")
      done < <(list_theme_names)
      if [[ "${#themes[@]}" -eq 0 ]]; then
        printf 'No themes found.\n' >&2
        return 1
      fi
      if (( plain == 1 )); then
        printf 'Legend: bg fg accent cursor selection (hex)\n\n'
        for theme in "${themes[@]}"; do
          if ! print_preview_all_row "$theme" "$plain"; then
            if [[ -n "${_THEME_LOAD_ERROR:-}" ]]; then
              printf 'Skipping %s: %s\n' "$theme" "$_THEME_LOAD_ERROR" >&2
            else
              printf 'Skipping %s: invalid theme file\n' "$theme" >&2
            fi
          fi
        done
      else
        local _active_t
        _active_t="$(read_theme_file)"
        _init_ui "$_active_t"
        local cl="$_cl" cr="$_cr"
        local sep
        sep="$(printf '%*s' 56 '' | tr ' ' '─')"
        printf "\n"
        printf "  ${cl}%-12s %-7s %-7s %-7s %-7s %-7s${cr}\n" \
          "" "bg" "fg" "accent" "cursor" "sel"
        printf "  ${cl}%s${cr}\n\n" "$sep"
        for theme in "${themes[@]}"; do
          if ! print_preview_all_row "$theme" "$plain"; then
            if [[ -n "${_THEME_LOAD_ERROR:-}" ]]; then
              printf 'Skipping %s: %s\n' "$theme" "$_THEME_LOAD_ERROR" >&2
            else
              printf 'Skipping %s: invalid theme file\n' "$theme" >&2
            fi
          fi
        done
      fi
      ;;
    *)
      if ! print_theme_preview "$target" "$plain"; then
        printf 'Failed to preview theme: %s\n' "$target" >&2
        if [[ -n "${_THEME_LOAD_ERROR:-}" ]]; then
          printf '%s\n' "$_THEME_LOAD_ERROR" >&2
        fi
        exit 1
      fi
      ;;
  esac
}

cmd_splash() {
  local action="${1:-}"
  local arg="${2:-}"
  local splash
  local _t _a _rgb _ca _cb _cd _cv _cr
  _t="$(read_theme_file)"
  _init_ui "$_t"

  case "$action" in
    ''|show|status)
      splash="$(read_splash_name)"
      printf "\n  ${_cd}splash${_cr}    ${_cb}${_ca}%s${_cr}\n\n" "$splash"
      ;;
    list)
      printf "\n  ${_cd}SPLASH ART${_cr}\n\n"
      while IFS= read -r splash; do
        printf "  ${_cb}${_ca}%s${_cr}\n" "$splash"
        print_splash_preview "$splash"
      done < <(list_splash_names)
      printf "\n"
      ;;
    custom)
      if [[ -z "$arg" ]]; then
        printf 'Usage: boo splash custom <file>\n' >&2
        exit 1
      fi
      if [[ ! -f "$arg" ]]; then
        printf 'Custom splash file not found: %s\n' "$arg" >&2
        exit 1
      fi
      mkdir -p "$(dirname "$CUSTOM_SPLASH_FILE")"
      cp "$arg" "$CUSTOM_SPLASH_FILE"
      write_splash_name "custom"
      printf "\n  ${_ca}✓${_cr}  ${_cv}splash  →  custom${_cr}\n\n"
      print_shell_apply_hint
      ;;
    none)
      write_splash_name "none"
      printf "\n  ${_ca}✓${_cr}  ${_cv}splash  →  disabled${_cr}\n\n"
      print_shell_apply_hint
      ;;
    reset)
      write_splash_name "$DEFAULT_SPLASH"
      printf "\n  ${_ca}✓${_cr}  ${_cv}splash  →  %s (default)${_cr}\n\n" "$DEFAULT_SPLASH"
      print_shell_apply_hint
      ;;
    apple|boo|saturn|eclipse|halo|monolith|minimal)
      write_splash_name "$action"
      printf "\n  ${_ca}✓${_cr}  ${_cv}splash  →  %s${_cr}\n\n" "$action"
      print_shell_apply_hint
      ;;
    *)
      printf 'Invalid splash option: %s\n' "$action" >&2
      printf 'Usage: boo splash [list|<name>|custom <file>|none|reset]\n' >&2
      exit 1
      ;;
  esac
}

cmd_doctor() {
  local action="${1:-check}"
  local _t
  _t="$(read_theme_file)"
  _init_ui "$_t"

  case "$action" in
    ''|check|status)
      if doctor_run_checks; then
        return 0
      fi
      printf "  \033[38;5;196m!\033[0m  ${_cv}some checks failed${_cr}  ${_cd}run boo doctor fix${_cr}\n\n" >&2
      return 1
      ;;
    fix|--fix)
      doctor_apply_fixes
      printf "\n  ${_cl}RE-CHECKING${_cr}\n\n"
      if doctor_run_checks; then
        printf "  \033[38;5;82m✓\033[0m  ${_cv}all checks passed${_cr}  ${_cd}run exec zsh to apply shell changes${_cr}\n\n"
        return 0
      fi
      printf "  \033[38;5;196m✗\033[0m  ${_cv}some checks still failed${_cr}\n\n" >&2
      return 1
      ;;
    *)
      printf 'Invalid doctor action: %s\n' "$action" >&2
      printf 'Usage: boo doctor [check|fix]\n' >&2
      exit 1
      ;;
  esac
}

cmd_upgrade() {
  local option="${1:-}"
  local upgrade_url="${BOO_UPGRADE_URL:-$DEFAULT_UPGRADE_URL}"
  local tmp

  case "$option" in
    ''|--yes|-y|yes)
      ;;
    help|-h|--help)
      printf 'Usage: boo upgrade\n'
      printf 'Downloads and runs the latest Boo installer.\n'
      printf 'Optional: set BOO_UPGRADE_URL to use a custom installer URL.\n'
      return 0
      ;;
    *)
      printf 'Invalid upgrade option: %s\n' "$option" >&2
      printf 'Usage: boo upgrade\n' >&2
      exit 1
      ;;
  esac

  if ! command -v curl >/dev/null 2>&1; then
    printf 'Missing required command: curl\n' >&2
    return 1
  fi

  if ! command -v bash >/dev/null 2>&1; then
    printf 'Missing required command: bash\n' >&2
    return 1
  fi

  tmp="$(mktemp)"
  if ! curl -fsSL "$upgrade_url" -o "$tmp"; then
    rm -f "$tmp"
    printf 'Failed to download installer from: %s\n' "$upgrade_url" >&2
    return 1
  fi

  if ! bash "$tmp"; then
    rm -f "$tmp"
    printf 'Upgrade failed.\n' >&2
    return 1
  fi

  rm -f "$tmp"

  if command -v hash >/dev/null 2>&1; then
    hash -r 2>/dev/null || true
  fi

  printf '\nBoo upgrade complete.\n'
  printf 'Run `exec zsh` to refresh your current shell.\n'
}

cmd_uninstall() {
  local option="${1:-}"
  local require_confirm=1
  local reply=""
  local removed_any=0

  case "$option" in
    '')
      ;;
    --yes|-y|yes)
      require_confirm=0
      ;;
    help|-h|--help)
      printf 'Usage: boo uninstall [--yes]\n'
      printf 'Removes Boo CLI/config, shell integration, and resets Ghostty config.\n'
      printf 'Ghostty config will be restored from backup or removed.\n'
      return 0
      ;;
    *)
      printf 'Invalid uninstall option: %s\n' "$option" >&2
      printf 'Usage: boo uninstall [--yes]\n' >&2
      exit 1
      ;;
  esac

  if (( require_confirm == 1 )); then
    printf 'This will remove Boo CLI/config and Boo shell integration from ~/.zshrc.\n'
    printf 'Ghostty config will be restored from backup or reset to defaults.\n'
    printf 'Continue? [y/N] '
    IFS= read -r reply || true
    case "$reply" in
      y|Y|yes|YES)
        ;;
      *)
        printf 'Uninstall cancelled.\n'
        return 1
        ;;
    esac
  fi

  if [[ -f "$ZSHRC_FILE" ]]; then
    if grep -qF "$BOO_BLOCK_START" "$ZSHRC_FILE" && grep -qF "$BOO_BLOCK_END" "$ZSHRC_FILE"; then
      remove_marked_block "$ZSHRC_FILE" "$BOO_BLOCK_START" "$BOO_BLOCK_END"
      printf 'Removed Boo source block: %s\n' "$ZSHRC_FILE"
      removed_any=1
    fi
  fi

  if [[ -f "$LOCAL_BIN_FILE" ]]; then
    rm -f "$LOCAL_BIN_FILE"
    printf 'Removed CLI binary: %s\n' "$LOCAL_BIN_FILE"
    removed_any=1
  fi

  local omp_file
  for omp_file in "$OMP_LEGACY_CONFIG" "${OMP_CONFIG_DIR}"/boo.*.omp.json; do
    [[ -e "$omp_file" ]] || continue
    rm -f "$omp_file"
    printf 'Removed prompt config: %s\n' "$omp_file"
    removed_any=1
  done

  # Reset Ghostty config to original/default before removing Boo state files.
  local ghostty_paths=("$GHOSTTY_CONFIG_PRIMARY" "$GHOSTTY_CONFIG_MAC")
  local ghostty_original_backups=("$GHOSTTY_ORIGINAL_BACKUP_PRIMARY" "$GHOSTTY_ORIGINAL_BACKUP_MAC")
  local idx gpath original_backup
  for idx in "${!ghostty_paths[@]}"; do
    gpath="${ghostty_paths[$idx]}"
    original_backup="${ghostty_original_backups[$idx]}"

    if [[ -f "$original_backup" ]]; then
      mkdir -p "$(dirname "$gpath")"
      cp "$original_backup" "$gpath"
      printf 'Restored Ghostty config from original backup: %s\n' "$original_backup"
      removed_any=1
      continue
    fi

    [[ -f "$gpath" ]] || continue

    # Fallback for legacy installs: restore oldest non-Boo backup, if present.
    local restore_backup=""
    local backup
    for backup in "${gpath}.backup-"*; do
      [[ -e "$backup" ]] || continue
      if is_boo_ghostty_config_file "$backup"; then
        continue
      fi
      if [[ -z "$restore_backup" || "$backup" -ot "$restore_backup" ]]; then
        restore_backup="$backup"
      fi
    done

    if [[ -n "$restore_backup" ]]; then
      cp "$restore_backup" "$gpath"
      printf 'Restored Ghostty config from backup: %s\n' "$restore_backup"
    else
      rm -f "$gpath"
      printf 'Removed Boo Ghostty config: %s (Ghostty will use defaults)\n' "$gpath"
    fi
    removed_any=1
  done

  if [[ -d "$CONFIG_DIR" ]]; then
    rm -rf "$CONFIG_DIR"
    printf 'Removed config directory: %s\n' "$CONFIG_DIR"
    removed_any=1
  fi

  if command -v hash >/dev/null 2>&1; then
    hash -r 2>/dev/null || true
  fi

  if (( removed_any == 0 )); then
    printf 'Nothing to remove. Boo is already uninstalled.\n'
    return 0
  fi

  printf '\nBoo uninstall complete.\n'
  printf 'Run `exec zsh` to refresh your current shell.\n'
}

cmd_status() {
  local mode theme accent rgb r2 g2 b2 r1 g1 b1
  local font_family font_size
  local prompt_configured prompt_effective
  local splash opacity

  mode="$(read_mode)"
  theme="$(read_theme_file)"
  _init_ui "$theme"
  accent="$_a"
  rgb="$_rgb"
  font_family="$(current_font_family)"
  font_size="$(current_font_size)"
  prompt_configured="$(read_prompt_backend)"
  prompt_effective="$(effective_prompt_backend)"
  splash="$(read_splash_name)"
  opacity="$(current_opacity)"
  collect_ghostty_targets

  # Split accent RGB and compute dark start color for gradient (1/8 brightness)
  IFS=';' read -r r2 g2 b2 <<< "$rgb"
  r1=$(( r2 / 8 )); g1=$(( g2 / 8 )); b1=$(( b2 / 8 ))

  local ca="$_ca" cb="$_cb" ci="\033[2m"
  local cl="$_cl" cv="$_cv" cd="$_cd" cr="$_cr"

  local inner=70
  local bar
  bar="$(printf '%*s' "$inner" '' | tr ' ' '─')"

  # _brow: print a full-width card row with right border
  # Usage: _brow <visible_char_count> <content_string>
  _brow() {
    local vis="$1" content="$2"
    local pad=$(( inner - vis ))
    (( pad < 0 )) && pad=0
    printf "  ${ca}│${cr}%b%${pad}s${ca}│${cr}\n" "$content" ""
  }

  # _brow2: two-column row, col1 value padded to 12 chars
  _brow2() {
    local l1="$1" v1="$2" l2="$3" v2="$4"
    local v1p=$(( 12 - ${#v1} ))
    (( v1p < 0 )) && v1p=0
    local vis=$(( 2 + ${#l1} + 2 + ${#v1} + v1p + 4 + ${#l2} + 2 + ${#v2} ))
    local row="  ${cl}${l1}${cr}  ${cv}${v1}${cr}$(printf '%'${v1p}'s')    ${cl}${l2}${cr}  ${cv}${v2}${cr}"
    _brow $vis "$row"
  }

  _bempty() { printf "  ${ca}│${cr}%${inner}s${ca}│${cr}\n" ""; }
  _bdiv()   { printf "  ${ca}├${bar}┤${cr}\n"; }

  # Shorten a path, abbreviating /Application Support/ to /…/
  _spath() {
    local p="${1/#$HOME/~}"
    local max="$2"
    p="${p/Application Support/…}"
    (( ${#p} > max )) && p="${p:0:$((max - 1))}…"
    printf '%s' "$p"
  }

  # ── Gradient bar: dark-accent → bright-accent across inner width ──
  local grad="" i gr gg gb
  for (( i = 0; i < inner; i++ )); do
    gr=$(( r1 + (r2 - r1) * i / (inner - 1) ))
    gg=$(( g1 + (g2 - g1) * i / (inner - 1) ))
    gb=$(( b1 + (b2 - b1) * i / (inner - 1) ))
    grad+="\033[48;2;${gr};${gg};${gb}m \033[0m"
  done

  # Title row: "  boo" left, "theme  " right, padded to inner
  local t_mid=$(( inner - 5 - ${#theme} - 2 ))
  (( t_mid < 0 )) && t_mid=0
  local title_row
  title_row="$(printf "  ${cb}${ca}boo${cr}%${t_mid}s${ci}${theme}${cr}  " "")"

  # ── Render ──
  printf "\n"
  printf "  ${ca}╭${bar}╮${cr}\n"
  _brow $inner "$grad"
  _brow $inner "$title_row"
  _bdiv

  # Theme swatch: "  theme     NAME    ████████  #accent"
  local sw_vis=$(( 26 + ${#theme} + ${#accent} ))
  local sw_row="  ${cl}theme${cr}     ${cb}${ca}${theme}${cr}    \033[38;2;${rgb}m\033[48;2;${rgb}m████████${cr}  ${cd}${accent}${cr}"
  _bempty
  _brow $sw_vis "$sw_row"
  _bempty

  # Two-column info
  _brow2 "mode"   "$mode"   "opacity" "$opacity"
  _brow2 "splash" "$splash" "prompt"  "$prompt_configured"
  if [[ "$prompt_configured" != "$prompt_effective" ]]; then
    local pe_vis=$(( 14 + ${#prompt_effective} ))
    _brow $pe_vis "  ${cd}↳ active: ${prompt_effective}${cr}"
  fi
  local fv=$(( 2 + 4 + 2 + ${#font_family} + 2 + ${#font_size} ))
  _brow $fv "  ${cl}font${cr}  ${cv}${font_family}${cr}  ${cd}${font_size}${cr}"
  _bempty

  # Ghostty paths
  _bdiv
  local file spath first=1
  local max_p=$(( inner - 14 ))
  for file in "${ghostty_targets[@]}"; do
    spath="$(_spath "$file" $max_p)"
    if (( first == 1 )); then
      _brow $(( 2 + 7 + 4 + ${#spath} )) "  ${cl}ghostty${cr}    ${cd}${spath}${cr}"
      first=0
    else
      _brow $(( 13 + ${#spath} )) "             ${cd}${spath}${cr}"
    fi
  done

  # Quick-action footer
  _bdiv
  local footer="  boo theme list  ·  boo opacity glass  ·  boo reload"
  _brow ${#footer} "  ${cd}boo theme list  ·  boo opacity glass  ·  boo reload${cr}"
  printf "  ${ca}╰${bar}╯${cr}\n"
  printf "\n"
}

subcommand="${1:-help}"
case "$subcommand" in
  mode)
    shift || true
    cmd_mode "${1:-}"
    ;;
  theme)
    shift || true
    cmd_theme "$@"
    ;;
  font)
    shift || true
    cmd_font "$@"
    ;;
  prompt)
    shift || true
    cmd_prompt "${1:-}" "${2:-}"
    ;;
  opacity)
    shift || true
    cmd_opacity "${1:-}"
    ;;
  reload)
    shift || true
    cmd_reload "${1:-}"
    ;;
  __theme_selector_preview)
    shift || true
    print_theme_selector_preview "${1:-}"
    ;;
  splash)
    shift || true
    cmd_splash "${1:-}" "${2:-}"
    ;;
  doctor)
    shift || true
    cmd_doctor "${1:-}"
    ;;
  upgrade|update)
    shift || true
    cmd_upgrade "${1:-}"
    ;;
  uninstall)
    shift || true
    cmd_uninstall "${1:-}"
    ;;
  status)
    cmd_status
    ;;
  help|-h|--help)
    print_help
    ;;
  *)
    if is_valid_theme "$subcommand" || theme_file_for_name "$subcommand" >/dev/null 2>&1; then
      cmd_theme "$subcommand"
    else
      printf 'Unknown command: %s\n\n' "$subcommand" >&2
      print_help >&2
      exit 1
    fi
    ;;
esac
